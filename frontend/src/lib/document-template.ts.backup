import { ValuationData } from "@/types/valuation";
import { STATIC_TEXTS } from "./static-texts-he";
import { LOCKED_HEBREW_TEXT, COMPLETE_TA_BINDINGS } from "./report-spec-hebrew";
import { formatBlockParcelFromString } from "./comparable-data-formatter";

// Import from extracted pdf modules
import {
  CompanySettings,
  FONT_FAMILIES,
  getFontFamily,
  getFontSize,
  PAGE_MIN_HEIGHT_MM,
  DEFAULT_FONT_FAMILY,
  hebrewMonths,
  numberToHebrewWords,
  formatDateNumeric,
  formatDateHebrew,
  parseNumeric,
  formatCurrency,
  formatNumber,
  formatRooms,
  formatFloor,
  escapeHtmlForTable,
  normalizeText,
  toRichHtml,
  getValueFromPaths,
  getSubParcelValue,
  getAddress,
  getReference,
  formatOwnership,
  summarizeAttachments,
  toArray,
  createDetailsTable,
  createComparablesTable,
  resolveCoverImageSources,
  collectInteriorImages,
  buildBaseCss,
  pageNumberScript,
  autoPaginateScript,
} from "./pdf";

// Re-export CompanySettings for backwards compatibility
export type { CompanySettings } from "./pdf";

// Helper functions needed for document generation
const mergeRecords = (
  ...records: Array<Record<string, any> | null | undefined>
) => {
  return records.reduce<Record<string, any>>((acc, record) => {
    if (!record || typeof record !== "object") return acc;
    Object.entries(record).forEach(([key, value]) => {
      if (value !== undefined && value !== null && acc[key] === undefined) {
        acc[key] = value;
      }
    });
    return acc;
  }, {});
};

const resolveLandRegistryData = (data: ValuationData) => {
  const mergedRegistry = mergeRecords(
    (data.extractedData as any)?.land_registry,
    (data.extractedData as any)?.landRegistry,
    (data as any).land_registry,
    (data as any).landRegistry,
  );
  const owners = toArray((mergedRegistry as any).owners).map((owner: any) => ({
    name: owner?.name || owner?.owner_name,
    idNumber: owner?.id_number || owner?.idNumber,
    share: owner?.ownership_share || owner?.share || "×©×œ××•×ª",
  }));
  const mortgages = toArray((mergedRegistry as any).mortgages).map(
    (mortgage: any) => ({
      rank: mortgage?.rank || mortgage?.mortgage_rank,
      share: mortgage?.share || mortgage?.mortgage_property_share,
      amount: mortgage?.amount || mortgage?.mortgage_amount,
      lenders: mortgage?.lenders || mortgage?.mortgage_lenders,
      borrowers: mortgage?.borrowers || mortgage?.mortgage_borrowers,
      registrationDate:
        mortgage?.registration_date || mortgage?.registrationDate,
      essence: mortgage?.essence || mortgage?.mortgage_essence,
    }),
  );
  const attachments = toArray((mergedRegistry as any).attachments).map(
    (attachment: any) => ({
      type: attachment?.type || attachment?.description,
      area: attachment?.area,
      color: attachment?.color,
      symbol: attachment?.symbol,
      sharedWith: attachment?.shared_with || attachment?.sharedWith,
    }),
  );
  const additionalAreas = toArray((mergedRegistry as any).additional_areas).map(
    (item: any) => ({
      type: item?.type,
      area: item?.area,
    }),
  );
  return {
    landRegistry: mergedRegistry,
    owners,
    mortgages,
    attachments,
    additionalAreas,
  };
};

const dedupeByKey = <T>(items: T[], getKey: (item: T) => string): T[] => {
  const seen = new Set<string>();
  return items.filter((item) => {
    const key = getKey(item);
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
};

const generateCustomTableHTML = (table: {
  id: string;
  title?: string;
  headers: string[];
  rows: string[][];
}): string => {
  const tableId = `custom-table-${table.id}`;
  const headerCells = table.headers
    .map(
      (h, i) =>
        `<th data-col="${i}">${escapeHtmlForTable(h || `×¢××•×“×” ${i + 1}`)}</th>`,
    )
    .join("");
  const bodyRows = table.rows
    .map((row, rowIdx) => {
      const cells = row
        .map(
          (cell, colIdx) =>
            `<td data-row="${rowIdx}" data-col="${colIdx}">${escapeHtmlForTable(cell || "")}</td>`,
        )
        .join("");
      return `<tr data-row="${rowIdx}">${cells}</tr>`;
    })
    .join("");
  return `<div id="${tableId}" class="custom-table-container section-block" data-custom-table-id="${table.id}">${table.title ? `<div class="sub-title">${escapeHtmlForTable(table.title)}</div>` : ""}<table class="table"><thead><tr>${headerCells}</tr></thead><tbody>${bodyRows}</tbody></table></div>`;
};

const generateAllCustomTablesHTML = (
  customTables?: Array<{
    id: string;
    title?: string;
    headers: string[];
    rows: string[][];
  }>,
): string => {
  if (!customTables || customTables.length === 0) return "";
  return `<section class="page custom-tables-section"><div class="chapter-title">× ×¡×¤×—×™× - ×˜×‘×œ××•×ª ××•×ª×××•×ª ××™×©×™×ª</div><div class="page-body">${customTables.map((table) => generateCustomTableHTML(table)).join("\n")}</div></section>`;
};

export function generateDocumentHTML(
  data: ValuationData,
  isPreview: boolean = true,
  companySettings?: CompanySettings,
): string {
  const customEdits = (data as any).customDocumentEdits || {};

  const valuationDate = data.valuationDate || new Date().toISOString();
  const valuationEffectiveDate = data.valuationEffectiveDate || valuationDate;
  const address = getAddress(data);
  const reference = getReference(data);
  // Parse final value safely (handles strings from backend)
  // Priority: finalValuation > section52.asset_value_nis > comparableDataAnalysis.estimatedValue > marketAnalysis.estimatedValue
  const finalValueRaw =
    (data as any).finalValuation ||
    ((data as any).comparableDataAnalysis?.section52 as any)?.asset_value_nis ||
    (data as any).comparableDataAnalysis?.estimatedValue ||
    ((data as any).comparableAnalysis as any)?.estimatedValue ||
    ((data as any).marketAnalysis as any)?.estimatedValue ||
    0;
  const finalValue = parseNumeric(finalValueRaw);

  // Debug logging (only in development)
  if (process.env.NODE_ENV === "development") {
    console.log("ğŸ“Š [Document Template] Final Value Sources:", {
      finalValuation: (data as any).finalValuation,
      section52Value: ((data as any).comparableDataAnalysis?.section52 as any)
        ?.asset_value_nis,
      comparableDataAnalysisEstimated: (data as any).comparableDataAnalysis
        ?.estimatedValue,
      comparableAnalysisEstimated: ((data as any).comparableAnalysis as any)
        ?.estimatedValue,
      marketAnalysisEstimated: ((data as any).marketAnalysis as any)
        ?.estimatedValue,
      finalValue,
    });
    console.log("ğŸ¢ [Document Template] Company Settings:", {
      hasCompanySettings: !!companySettings,
      hasFooterLogo: !!companySettings?.footerLogo,
      footerLogo: companySettings?.footerLogo,
      hasCompanyLogo: !!companySettings?.companyLogo,
    });
  }

  // getValueFromPaths is now defined at module level (above)

  const neighborhoodName = normalizeText(data.neighborhood, "×©×›×•× ×” ×œ× ×¦×•×™× ×”");
  // Note: According to PRD, this should be AI-generated, but for now we keep placeholder text
  // Check for AI-generated environment description first
  const environmentDescription = getValueFromPaths(data, [
    "extractedData.environmentDescription",
    "extractedData.environment_description",
    "environmentDescription",
  ]);
  const environmentParagraph =
    environmentDescription ||
    `×©×›×•× ×ª ${neighborhoodName}${data.city ? ` ×‘${data.city}` : ""} × ×”× ×™×ª ×× ×’×™×©×•×ª ×˜×•×‘×”, ×©×™×¨×•×ª×™× ×§×”×™×œ×ª×™×™× ×•××¨×§× ××’×•×¨×™× ××’×•×•×Ÿ.`;

  const { landRegistry, owners, mortgages, attachments, additionalAreas } =
    resolveLandRegistryData(data);

  const plotParagraph = `×—×œ×§×” ${formatNumber(
    getValueFromPaths(data, [
      "extractedData.chelka",
      "extractedData.parcel",
      "extractedData.land_registry.chelka",
      "extractedData.land_registry.parcel",
      "land_registry.chelka",
      "parcel",
    ]) ||
      (data as any).land_registry?.chelka ||
      landRegistry?.chelka ||
      data.parcel,
  )} ×‘×’×•×© ${formatNumber(
    getValueFromPaths(data, [
      "extractedData.gush",
      "extractedData.land_registry.gush",
      "land_registry.gush",
      "gush",
    ]) ||
      (data as any).land_registry?.gush ||
      landRegistry?.gush ||
      data.gush,
  )} ×‘×©×˜×— ×§×¨×§×¢ ×¨×©×•× ×©×œ ${formatNumber(
    getValueFromPaths(data, [
      "extractedData.parcelArea",
      "extractedData.parcel_area",
      "extractedData.total_plot_area",
      "extractedData.land_registry.parcelArea",
      "extractedData.land_registry.parcel_area",
      "extractedData.land_registry.total_plot_area",
      "land_registry.total_plot_area",
      "parcelArea",
    ]) ||
      (data as any).parcelArea ||
      (data as any).land_registry?.total_plot_area ||
      (data.extractedData as any)?.total_plot_area ||
      landRegistry?.total_plot_area,
  )} ×"×¨.`;

  const unitDescription = normalizeText(
    getValueFromPaths(data, [
      "extractedData.unitDescription",
      "extractedData.unit_description",
      "extractedData.land_registry.unitDescription",
      "extractedData.land_registry.unit_description",
      "land_registry.unit_description",
      "unit_description",
    ]) ||
      landRegistry?.unit_description ||
      data.propertyEssence ||
      (data as any).land_registry?.unit_description ||
      "×“×™×¨×ª ××’×•×¨×™×",
  );
  const buildingIdentifier = normalizeText(
    getValueFromPaths(data, [
      "extractedData.buildingNumber",
      "extractedData.building_number",
      "extractedData.land_registry.buildingNumber",
      "extractedData.land_registry.building_number",
      "land_registry.building_number",
      "buildingNumber",
    ]) ||
      landRegistry?.building_number ||
      landRegistry?.buildingNumber ||
      (data as any).land_registry?.building_number ||
      (data as any).buildingNumber,
    "",
  );
  const buildingCondition = normalizeText(
    getValueFromPaths(data, [
      "extractedData.buildingCondition",
      "extractedData.building_condition",
      "extractedData.exterior_analysis.buildingCondition",
      "buildingCondition",
    ]) ||
      (data as any).buildingCondition ||
      (data as any).land_registry?.building_condition ||
      landRegistry?.building_condition,
    "×‘××¦×‘ ×ª×—×–×•×§×ª×™ ×˜×•×‘",
  );
  const propertyDescriptionParts = [unitDescription];
  const floorText = formatFloor(
    landRegistry?.floor || (data as any).land_registry?.floor || data.floor,
  );
  if (floorText) {
    propertyDescriptionParts.push(floorText);
  }
  if (buildingIdentifier) {
    propertyDescriptionParts.push(`×‘××‘× ×” ${buildingIdentifier}`);
  }
  // airDirections is now a string like "×¦×¤×•×Ÿ-××–×¨×—"
  const airDirectionsText =
    typeof data.airDirections === "string" && data.airDirections.trim()
      ? `×”×¤×•× ×” ×œ×›×™×•×•× ×™× ${data.airDirections.trim()}`
      : "";
  if (airDirectionsText) {
    propertyDescriptionParts.push(airDirectionsText);
  }
  const propertyParagraph = `${propertyDescriptionParts.join(" ")}. ×”× ×›×¡ ××¦×•×™ ×‘×¨××ª ×ª×—×–×•×§×” ${buildingCondition}.`;
  const interiorNarrative =
    (data as any).extractedData?.propertyLayoutDescription ||
    (data as any).interior_analysis?.description ||
    "";
  const facadeAssessment =
    (data as any).extractedData?.overallAssessment ||
    (data as any).facadeAssessment ||
    "";

  const sharedBuildingData =
    (data as any).shared_building ||
    (data.extractedData as any)?.shared_building ||
    {};
  const sharedBuildingRaw = sharedBuildingData?.rawData || {};
  const sharedBuildingAddresses: string[] = toArray(
    sharedBuildingData?.building_address ||
      sharedBuildingRaw?.all_addresses?.value,
  ).filter(
    (value: any): value is string =>
      typeof value === "string" && value.trim().length > 0,
  );
  const sharedBuildingDescription = normalizeText(
    sharedBuildingData?.building_description ||
      sharedBuildingRaw?.building_description?.value ||
      sharedBuildingRaw?.building_description_formatted,
    "",
  );
  const sharedBuildingNotes = normalizeText(
    sharedBuildingRaw?.validationNotes,
    "",
  );
  const sharedBuildingEntries: string[] = toArray(
    sharedBuildingRaw?.buildings_info?.value,
  )
    .map((info) => {
      const buildingNumber = info?.building_number || info?.buildingNumber;
      const floors = info?.floors;
      const addressText = info?.address;
      const subPlots = info?.sub_plots_count || info?.subPlotsCount;
      const parts: string[] = [];
      if (buildingNumber) {
        parts.push(`××‘× ×” ${buildingNumber}`);
      }
      if (floors) {
        parts.push(`${floors} ×§×•××•×ª`);
      }
      if (subPlots) {
        parts.push(`${subPlots} ×ª×ª×™ ×—×œ×§×•×ª`);
      }
      const label = parts.join(" â€¢ ");
      return label
        ? `${label}${addressText ? ` â€“ ${addressText}` : ""}`
        : addressText || "";
    })
    .filter((text: string) => text && text.trim().length > 0);

  const buildingMetrics = [
    {
      label: "×¡×•×’ ××‘× ×”",
      value: normalizeText(
        getValueFromPaths(data, [
          "extractedData.buildingType",
          "extractedData.building_type",
          "buildingType",
        ]) ||
          (data as any).buildingType ||
          landRegistry?.building_type ||
          sharedBuildingDescription,
        "",
      ),
    },
    {
      label: "××¡×¤×¨ ××‘× ×™×",
      value: (() => {
        const candidate =
          getValueFromPaths(data, [
            "extractedData.numberOfBuildings",
            "extractedData.number_of_buildings",
            "extractedData.shared_building.numberOfBuildings",
            "extractedData.shared_building.number_of_buildings",
            "shared_building.buildings_count",
          ]) ||
          sharedBuildingData?.buildings_count ||
          (sharedBuildingEntries.length > 0
            ? sharedBuildingEntries.length
            : "") ||
          landRegistry?.buildings_count;
        return candidate ? formatNumber(candidate, "") : "";
      })(),
    },
    {
      label: "××¡×¤×¨ ×§×•××•×ª",
      value: normalizeText(
        getValueFromPaths(data, [
          "extractedData.buildingFloors",
          "extractedData.building_floors",
          "extractedData.shared_building.buildingFloors",
          "extractedData.shared_building.building_floors",
          "buildingFloors",
        ]) ||
          (data as any).buildingFloors ||
          sharedBuildingData?.building_floors ||
          sharedBuildingRaw?.building_floors?.value ||
          landRegistry?.building_floors,
        "",
      ),
    },
    {
      label: "××¡×¤×¨ ×™×—×™×“×•×ª",
      value: (() => {
        const candidate =
          getValueFromPaths(data, [
            "extractedData.buildingUnits",
            "extractedData.building_units",
            "extractedData.shared_building.buildingUnits",
            "extractedData.shared_building.building_units",
            "buildingUnits",
          ]) ||
          (data as any).buildingUnits ||
          sharedBuildingData?.total_sub_plots ||
          sharedBuildingRaw?.total_sub_plots?.value ||
          sharedBuildingRaw?.building_sub_plots_count?.value ||
          landRegistry?.sub_plots_count;
        return candidate ? formatNumber(candidate, "") : "";
      })(),
    },
    {
      label: "×©×™××•×©×™× ××•×ª×¨×™×",
      value: normalizeText(
        getValueFromPaths(data, [
          "extractedData.permittedUse",
          "extractedData.permitted_use",
          "extractedData.building_permit.permittedUse",
          "permittedUse",
        ]) ||
          (data as any).permittedUse ||
          (data as any).buildingRights ||
          (data as any).building_permit?.permitted_usage ||
          landRegistry?.permitted_usage,
        "",
      ),
    },
    {
      label: "×©×˜×—×™× ××©×•×ª×¤×™×",
      value: normalizeText(
        getValueFromPaths(data, [
          "extractedData.commonParts",
          "extractedData.common_parts",
          "extractedData.sharedAreas",
          "extractedData.shared_areas",
          "extractedData.land_registry.commonParts",
          "extractedData.land_registry.common_parts",
          "land_registry.shared_property",
          "sharedAreas",
        ]) ||
          (data as any).sharedAreas ||
          sharedBuildingRaw?.specific_sub_plot?.value?.shared_property_parts ||
          landRegistry?.shared_property,
        "",
      ),
    },
    {
      label: "××¦×‘ ×ª×—×–×•×§×”",
      value: normalizeText(
        getValueFromPaths(data, [
          "extractedData.buildingCondition",
          "extractedData.building_condition",
          "extractedData.exterior_analysis.buildingCondition",
          "buildingCondition",
        ]) ||
          (data as any).buildingCondition ||
          landRegistry?.building_condition ||
          sharedBuildingRaw?.conditionAssessment,
        "",
      ),
    },
  ].filter((row) => row.value && row.value !== "â€”");

  const condoOrderDate = formatDateNumeric(
    sharedBuildingData?.order_date ||
      sharedBuildingRaw?.order_date?.value ||
      sharedBuildingRaw?.condo_order_date,
  );
  const sharedBuildingParagraph = condoOrderDate
    ? `××¢×™×•×Ÿ ×‘×¦×• ×¨×™×©×•× ×”×‘×™×ª ×”××©×•×ª×£ ××™×•× ${condoOrderDate} ×¢×•×œ×™× ×”×¤×¨×˜×™× ×”×¨×œ×•×•× ×˜×™×™× ×”×‘××™×:`
    : sharedBuildingDescription ||
      "××¢×™×•×Ÿ ×‘×¦×• ×¨×™×©×•× ×”×‘×™×ª ×”××©×•×ª×£ ×¢×•×œ×™× ×”×¤×¨×˜×™× ×”×¨×œ×•×•× ×˜×™×™× ×”×‘××™×:";
  const primaryPlanningPlans: any[] = Array.isArray((data as any).planningPlans)
    ? (data as any).planningPlans
    : [];
  const supplementalPlanningPlans = [
    ...toArray((data as any).land_registry?.planning_plans),
    ...toArray((data as any).land_registry?.planningPlans),
    ...toArray((landRegistry as any)?.planning_plans),
    ...toArray((landRegistry as any)?.planningPlans),
    ...toArray((data.extractedData as any)?.planning_plans),
    ...toArray((data.extractedData as any)?.planningPlans),
  ];
  const planningPlans: any[] = dedupeByKey(
    [...primaryPlanningPlans, ...supplementalPlanningPlans],
    (plan: any) =>
      `${plan?.plan_number || plan?.planNumber || plan?.id || plan?.name || ""}`,
  );
  const planningParagraph =
    planningPlans.length > 0
      ? `×”×ª×›× ×™×•×ª ×”×¨×œ×•×•× ×˜×™×•×ª ×›×•×œ×œ×•×ª ${planningPlans
          .map(
            (plan) =>
              `${plan.plan_number || plan.planNumber || "×ª×›× ×™×ª"} (${plan.status || "×‘×ª×•×§×£"})`,
          )
          .join(", ")}.`
      : "×œ× ××•×ª×¨×• ×ª×›× ×™×•×ª × ×•×¡×¤×•×ª ××¢×‘×¨ ×œ×ª×›× ×™×ª ×”××ª××¨ ×”×—×œ×” ×‘××§×•×.";

  const buildingPermitParagraph = data.buildingPermitNumber
    ? `×”×™×ª×¨ ×‘× ×™×” ××¡' ${data.buildingPermitNumber} ××™×•× ${formatDateNumeric((data as any).land_registry?.building_permit_date || data.buildingPermitDate || "")} ×××©×¨ ××ª ×”×‘× ×™×” ×‘×¤×•×¢×œ.`
    : "×”××™×“×¢ ×¢×œ ×”×™×ª×¨×™ ×”×‘× ×™×” ×™×¢×•×“×›×Ÿ ×œ××—×¨ ×¢×™×•×Ÿ ×‘×ª×™×§ ×”×‘× ×™×™×Ÿ.";

  const buildingPermit: Record<string, any> =
    (data as any).building_permit || {};

  // Page header and footer components for regular pages - MMBL Style - Compact
  const pageHeader = `
    <div class="page-header" style="margin-bottom: 6px; padding-bottom: 2px;">
      ${
        companySettings?.companyLogo
          ? `
    <div class="page-header-brand">
          <img src="${companySettings.companyLogo}" alt="×œ×•×’×•" style="max-height: 40px;" />
        </div>
      `
          : `
        <div class="page-header-logo" style="font-size: 20pt; margin-bottom: 0;">MMBL.</div>
        <div class="page-header-company" style="font-size: 8pt;">${companySettings?.companyName || "×× ×©×”-×œ×™×‘×•×‘×™×¥ ×©×××•×ª ××§×¨×§×¢×™×Ÿ"}</div>
        <div class="page-header-tagline" style="font-size: 7pt;">${companySettings?.companySlogan || "×œ×™×•×•×™ ×•×™×™×¢×•×¥ ×‘×ª×—×•× ×”××§×¨×§×¢×™×Ÿ"}</div>
      `
      }
    </div>
  `;

  // Footer block for regular pages

  // Footer block for regular pages - ONLY the footerLogo from settings
  const footerBlock = `
    <div class="page-footer" style="display: flex; justify-content: center; align-items: center; padding-bottom: 0;">
      ${
        companySettings?.footerLogo
          ? `
        <img src="${companySettings.footerLogo}" alt="footer" style="max-height: 100px; width: 100%; object-fit: contain;" />
      `
          : ""
      }
      <div class="page-number" data-page-number="" style="position: absolute; bottom: 2mm; left: 18mm;"></div>
    </div>
  `;

  // Cover footer block - ONLY the footerLogo from settings, at the very bottom
  const coverFooterBlock = `
    <div class="cover-footer-container">
      ${
        companySettings?.footerLogo
          ? `
        <img src="${companySettings.footerLogo}" alt="footer" />
        `
          : ""
      }
    </div>
  `;

  const buildingPermitRows: Array<{ label: string; value: string }> = [
    {
      label: "××¡×¤×¨ ×”×™×ª×¨",
      value: normalizeText(
        buildingPermit?.permit_number || data.buildingPermitNumber,
        "",
      ),
    },
    {
      label: "×ª××¨×™×š ×”×™×ª×¨",
      value: (() => {
        const dateCandidate =
          buildingPermit?.permit_issue_date ||
          buildingPermit?.permit_date ||
          data.buildingPermitDate;
        const formatted = formatDateNumeric(dateCandidate);
        return formatted && formatted !== "â€”" ? formatted : "";
      })(),
    },
    {
      label: "×©×™××•×© ××•×ª×¨",
      value: normalizeText(
        buildingPermit?.permitted_usage ||
          (data as any).permittedUse ||
          (data as any).buildingRights,
        "",
      ),
    },
    {
      label: "×ª×™××•×¨ ×”×‘× ×™×”",
      value: normalizeText(
        buildingPermit?.building_description || data.buildingDescription,
        "",
      ),
    },
    {
      label: "×•×¢×“×” ××§×•××™×ª",
      value: normalizeText(buildingPermit?.local_committee_name, ""),
    },
    {
      label: "×’×•×© / ×—×œ×§×”",
      value: [
        formatNumber(buildingPermit?.gush, ""),
        formatNumber(buildingPermit?.chelka, ""),
        formatNumber(buildingPermit?.sub_chelka, ""),
      ]
        .filter(Boolean)
        .map((value, index) =>
          index === 0
            ? `×’×•×© ${value}`
            : index === 1
              ? `×—×œ×§×” ${value}`
              : `×ª×ª ×—×œ×§×” ${value}`,
        )
        .join(" â€¢ "),
    },
  ].filter((row) => row.value && row.value !== "â€”");

  // ===== COVER PAGE =====
  const reportDate = formatDateHebrew(valuationDate);

  // Format address for cover page: "×¨×—×•×‘ {{Street}} ,{{BuildingNumber}}, ×©×›×•× ×ª {{Neighborhood}}, {{City}}"
  const formattedAddress = [
    data.street ? `×¨×—×•×‘ ${data.street}` : "",
    data.buildingNumber ? `${data.buildingNumber}` : "",
    data.neighborhood ? `×©×›×•× ×ª ${data.neighborhood}` : "",
    data.city || "",
  ]
    .filter(Boolean)
    .join(", ")
    .replace(" , ,", " ,");

  const headerBlock = `
    <section class="page cover">
      <!-- Cover Header with Logo - Compact -->
      <div class="cover-header">
        ${
          companySettings?.companyLogo
            ? `
          <div class="page-header-brand">
            <img src="${companySettings.companyLogo}" alt="×œ×•×’×•" style="max-height: 55px;" />
                  </div>
        `
            : `
          <div class="page-header-logo">MMBL.</div>
          <div class="page-header-company">${companySettings?.companyName || "×× ×©×”-×œ×™×‘×•×‘×™×¥ ×©×××•×ª ××§×¨×§×¢×™×Ÿ"}</div>
          <div class="page-header-tagline">${companySettings?.companySlogan || "×œ×™×•×•×™ ×•×™×™×¢×•×¥ ×‘×ª×—×•× ×”××§×¨×§×¢×™×Ÿ"}</div>
        `
        }
                  </div>
      
      <!-- Title Box with Gray Background -->
      <div class="cover-title-box">
        <div class="cover-title-main">×—×•×•×ª ×“×¢×ª ×‘×¢× ×™×™×Ÿ</div>
        <div class="cover-title-sub">${LOCKED_HEBREW_TEXT.coverMainTitle}</div>
        <div class="cover-title-type">${LOCKED_HEBREW_TEXT.coverSubtitle}</div>
        <div class="cover-address">${formattedAddress}</div>
      </div>
      
      <!-- Cover Content Container for Image -->
      <div style="flex: 1; display: flex; flex-direction: column; min-height: 0; padding-bottom: 150px;">
        <!-- Cover Image -->
        ${(() => {
          const coverImages = resolveCoverImageSources(data);
          if (!coverImages.length) {
            return `
            <div class="cover-image-frame" style="display: flex; align-items: center; justify-content: center; min-height: 200px; background: #f5f5f5;">
              <div style="text-align: center; color: #999999;">
                <div style="font-size: 36px; margin-bottom: 8px;">ğŸ“·</div>
                <div style="font-size: 10pt;">×ª××•× ×” ×—×™×¦×•× ×™×ª ×œ× ×”×•×¢×œ×ª×”</div>
              </div>
              </div>
        `;
          }
          return `
        <div class="cover-image-frame">
            <img src="${coverImages[0]}" alt="×ª××•× ×ª ×—×–×™×ª ×”×‘× ×™×™×Ÿ" data-managed-image="true" />
              </div>
      `;
        })()}
      </div>
      
      <!-- Cover Footer -->
      ${coverFooterBlock}
    </section>
  `;

  // ===== OPENING PAGE =====
  const formatDateNumericForPage2 = (value?: string) => {
    if (!value) {
      const today = new Date();
      return `${today.getDate().toString().padStart(2, "0")}/${(today.getMonth() + 1).toString().padStart(2, "0")}/${today.getFullYear()}`;
    }
    try {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) {
        return "â€”";
      }
      const day = date.getDate().toString().padStart(2, "0");
      const month = (date.getMonth() + 1).toString().padStart(2, "0");
      const year = date.getFullYear().toString();
      return `${day}/${month}/${year}`;
    } catch {
      return "â€”";
    }
  };

  const introductionPage = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Header with Date/Reference and Recipient -->
        <div class="opening-header">
          <div>
            <div><strong>×œ×›×‘×•×“,</strong></div>
            <div>${(data as any).clientTitle ? `${normalizeText((data as any).clientTitle)} ` : ""}${normalizeText(data.clientName)}${(data as any).clientNote ? `,` : ""}</div>
            ${(data as any).clientNote ? `<div>${normalizeText((data as any).clientNote)}</div>` : ""}
        </div>
          <div style="text-align: left;">
        <div><strong>×ª××¨×™×š:</strong> ${formatDateHebrew(valuationDate)}</div>
            <div><strong>×¡×™×× × ×•:</strong> ${reference}</div>
        </div>
        </div>
        
        <!-- Title Section - Centered -->
        <div class="opening-title-section">
          <div class="cover-title-main">×—×•×•×ª ×“×¢×ª ×‘×¢× ×™×™×Ÿ</div>
          <div class="cover-title-sub">${LOCKED_HEBREW_TEXT.coverMainTitle}</div>
          <div class="cover-title-type">${LOCKED_HEBREW_TEXT.coverSubtitle}</div>
          <div class="cover-address">${formattedAddress}</div>
        </div>
        
        <!-- Introduction Text -->
        <p>${LOCKED_HEBREW_TEXT.openingIntro}</p>
        
        <!-- Purpose Section -->
        <div class="section-block">
          <div class="sub-title">${LOCKED_HEBREW_TEXT.purposeTitle}</div>
          <p>${LOCKED_HEBREW_TEXT.purposeText}</p>
          <p>${LOCKED_HEBREW_TEXT.limitationText}</p>
        </div>
        
        <!-- Client & Dates -->
        <div class="section-block">
          <p><span class="sub-title">××–××™×Ÿ ×—×•×•×ª ×”×“×¢×ª:</span> ${(data as any).clientTitle ? `${normalizeText((data as any).clientTitle)} ` : ""}${normalizeText(data.clientName)}${(data as any).clientNote ? `, ${normalizeText((data as any).clientNote)}` : ""}.</p>
          <p><span class="sub-title">××•×¢×“ ×”×‘×™×§×•×¨ ×‘× ×›×¡:</span> ${formatDateHebrew(valuationEffectiveDate)}, ×¢×œ ×™×“×™ ${normalizeText(data.shamayName, "×©×××™ ××§×¨×§×¢×™×Ÿ ××•×¡××š")}. ×œ×‘×™×§×•×¨ ×”×ª×œ×•×•×ª×” ×‘×¢×œ×ª ×”×–×›×•×™×•×ª ×‘× ×›×¡.</p>
          <p><span class="sub-title">×ª××¨×™×š ×§×•×‘×¢ ×œ×©×•××”:</span> ${formatDateHebrew(valuationEffectiveDate)}, ××•×¢×“ ×”×‘×™×§×•×¨ ×‘× ×›×¡.</p>
          </div>
        
        <!-- Property Details Table -->
        <div class="section-block">
          <div class="sub-title">×¤×¨×˜×™ ×”× ×›×¡:</div>
          <table class="table details-table">
            <tbody>
              ${createDetailsTable(data)}
            </tbody>
          </table>
        </div>
        
        <!-- Footnotes -->
        <div class="page-note">
          <sup class="footnote-ref">1</sup> ×‘×”×ª×× ×œ× ×¡×— ×¨×™×©×•× ××§×¨×§×¢×™×Ÿ ××™×•× ${formatDateNumeric((data as any).land_registry?.extractDate || data.extractDate)}.<br/>
          ${data.buildingPermitNumber ? `<sup class="footnote-ref">2</sup> ×¢×¤"×™ ××“×™×“×” ××ª×•×š ×ª×›× ×™×ª ×”×™×ª×¨ ×‘× ×™×” ××¡' ${data.buildingPermitNumber} ××™×•× ${formatDateNumeric(data.buildingPermitDate || undefined)}.` : ""}
      </div>
      </div>
      
      ${footerBlock}
    </section>
  `;

  // ===== CHAPTER 1 =====
  const interiorGallery = collectInteriorImages(data);
  const sectionOne = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter Title -->
        <div class="chapter-title">1.&emsp;${LOCKED_HEBREW_TEXT.chapter1Title}</div>
        
        <!-- Section 1.1 - Environment Description -->
        <div class="section-block">
          <div class="section-title">1.1&emsp;×ª×™××•×¨ ×”×¡×‘×™×‘×”</div>
          <p>${environmentParagraph}</p>
              </div>
        
        <!-- Environment Map - Large map for Section 1.1 -->
        ${(() => {
          // Use new wideArea field, fallback to legacy cropMode0
          const wideAreaMap =
            data.gisScreenshots?.wideArea || data.gisScreenshots?.cropMode0;
          return wideAreaMap
            ? `
          <div class="section-block">
            <p>××¤×ª ×”×¡×‘×™×‘×” (××™×§×•× × ×©×•× ×—×•×•×ª ×”×“×¢×ª ××¡×•××Ÿ, ×œ×”××—×©×” ×‘×œ×‘×“):</p>
            <figure style="margin-top: 10px;">
              <img src="${wideAreaMap}" alt="××¤×ª ×”×¡×‘×™×‘×”" style="max-width: 100%; border: 1px solid #cccccc;" />
            </figure>
          </div>
          `
            : "";
        })()}
        <!-- Section 1.2 - Plot Description -->
        <div class="section-block">
          <div class="section-title">1.2&emsp;×ª×™××•×¨ ×”×—×œ×§×”</div>
          <p>${plotParagraph}</p>
                </div>
        
        <!-- Plot Images (Side by Side) - Zoomed maps for Section 1.2 -->
        ${(() => {
          // Use new zoomedNoTazea and zoomedWithTazea fields, fallback to legacy cropMode0/cropMode1
          const zoomedNoTazeaMap =
            data.gisScreenshots?.zoomedNoTazea ||
            data.gisScreenshots?.cropMode0;
          const zoomedWithTazeaMap =
            data.gisScreenshots?.zoomedWithTazea ||
            data.gisScreenshots?.cropMode1;

          return zoomedNoTazeaMap || zoomedWithTazeaMap
            ? `
          <div class="section-block">
            <p>×ª×©×¨×™×˜ ×”×—×œ×§×” ×•×ª×¦"×, ××ª×•×š ×”××ª×¨ ×”×”× ×“×¡×™ ×©×œ ×”×¢×™×¨×™×™×” (×œ×”××—×©×” ×‘×œ×‘×“):</p>
            <div class="side-by-side-images">
              ${
                zoomedWithTazeaMap
                  ? `
                <figure>
                  <img src="${zoomedWithTazeaMap}" alt="×ª×¦×´×" />
                  <figcaption style="text-align: center; font-size: 11px; color: #666; margin-top: 4px;">×¢× ×ª×¦×´×</figcaption>
                </figure>
              `
                  : ""
              }
              ${
                zoomedNoTazeaMap
                  ? `
                <figure>
                  <img src="${zoomedNoTazeaMap}" alt="×ª×©×¨×™×˜ ×—×œ×§×”" />
                  <figcaption style="text-align: center; font-size: 11px; color: #666; margin-top: 4px;">×œ×œ× ×ª×¦×´×</figcaption>
                </figure>
              `
                  : ""
              }
            </div>
          </div>
          `
            : "";
        })()}
        
        <!-- Boundaries -->
        ${(() => {
          const boundaryNorth = getValueFromPaths(data, [
            "extractedData.plotBoundaryNorth",
            "extractedData.plot_boundary_north",
            "extractedData.boundary_north",
            "extractedData.gis_analysis.boundary_north",
            "gis_analysis.boundary_north",
            "parcelBoundaries.north",
            "boundaryNorth",
            "boundary_north",
          ]);
          const boundarySouth = getValueFromPaths(data, [
            "extractedData.plotBoundarySouth",
            "extractedData.plot_boundary_south",
            "extractedData.boundary_south",
            "extractedData.gis_analysis.boundary_south",
            "gis_analysis.boundary_south",
            "parcelBoundaries.south",
            "boundarySouth",
            "boundary_south",
          ]);
          const boundaryEast = getValueFromPaths(data, [
            "extractedData.plotBoundaryEast",
            "extractedData.plot_boundary_east",
            "extractedData.boundary_east",
            "extractedData.gis_analysis.boundary_east",
            "gis_analysis.boundary_east",
            "parcelBoundaries.east",
            "boundaryEast",
            "boundary_east",
          ]);
          const boundaryWest = getValueFromPaths(data, [
            "extractedData.plotBoundaryWest",
            "extractedData.plot_boundary_west",
            "extractedData.boundary_west",
            "extractedData.gis_analysis.boundary_west",
            "gis_analysis.boundary_west",
            "parcelBoundaries.west",
            "boundaryWest",
            "boundary_west",
          ]);

          // Use actual data if available, otherwise use standard placeholders for demo/mock
          const westVal = normalizeText(boundaryWest) || "×—×–×™×ª ×œ×¨×—×•×‘ ×”×¨×™ ×”×’×œ×¢×“";
          const southVal = normalizeText(boundarySouth) || "×—×œ×§×” 399";
          const eastVal = normalizeText(boundaryEast) || "×—×œ×§×” 400";
          const northVal = normalizeText(boundaryNorth) || "×—×œ×§×” 397";

          return `
              <div class="section-block">
              <p><strong>×’×‘×•×œ×•×ª ×”×—×œ×§×”:</strong> ××¢×¨×‘ â€“ ${westVal}, ×“×¨×•× â€“ ${southVal}, ××–×¨×— â€“ ${eastVal}, ×¦×¤×•×Ÿ â€“ ${northVal}.</p>
              </div>
            `;
        })()}
        <!-- Section 1.3 - Property Description -->
        <div class="section-block">
          <div class="section-title">1.3&emsp;×ª×™××•×¨ × ×©×•× ×”×©×•××”</div>
          <p>× ×©×•× ×”×©×•××” ×”×™× ×• ×ª×ª ×—×œ×§×” ${
            formatNumber(getSubParcelValue(data, landRegistry)) || "â€”"
          } ×”××”×•×•×” ${unitDescription || "×“×™×¨×ª ××’×•×¨×™×"}${floorText ? ` ${floorText}` : ""}${data.rooms ? ` ×‘×ª ${data.rooms} ×—×“'` : ""}${(() => {
            // airDirections is now a string like "×¦×¤×•×Ÿ-××–×¨×—-×“×¨×•×"
            const airDir =
              typeof data.airDirections === "string" &&
              data.airDirections.trim()
                ? data.airDirections.trim()
                : "";
            if (airDir) {
              return ` ×”×¤×•× ×” ×œ×›×™×•×•× ×™× ${airDir}`;
            }
            return "";
          })()}${(() => {
            const parkingCount = attachments.filter(
              (a: any) =>
                a.type && (a.type.includes("×—× ×™×”") || a.type.includes("×—× ×™×™×”")),
            ).length;
            const storageCount = attachments.filter(
              (a: any) => a.type && a.type.includes("××—×¡×Ÿ"),
            ).length;
            const parts: string[] = [];
            if (parkingCount > 0) parts.push(`${parkingCount} ××§×•××•×ª ×—× ×™×”`);
            if (storageCount > 0) parts.push("××—×¡×Ÿ");
            return parts.length > 0 ? `, ×”×¦××•×“×•×ª ××œ×™×” ${parts.join(" ×•")}` : "";
          })()}.</p>
          <p>×”×“×™×¨×” ×‘×©×˜×— ×¨×©×•× ×©×œ ${
            formatNumber(
              getValueFromPaths(data, [
                "extractedData.registeredArea",
                "extractedData.registered_area",
                "extractedData.apartment_registered_area",
                "extractedData.land_registry.registeredArea",
                "extractedData.land_registry.registered_area",
                "extractedData.land_registry.apartment_registered_area",
                "land_registry.apartment_registered_area",
                "registeredArea",
              ]) ||
                (data as any).registeredArea ||
                data.extractedData?.apartment_registered_area ||
                landRegistry?.apartment_registered_area,
            ) || "â€”"
          } ×"×¨${(() => {
            const builtArea = getValueFromPaths(data, [
              "extractedData.builtArea",
              "extractedData.built_area",
              "extractedData.land_registry.builtArea",
              "extractedData.land_registry.built_area",
              "land_registry.builtArea",
              "builtArea",
            ]);
            return builtArea
              ? ` ×•×‘×©×˜×— ×‘× ×•×™ ×©×œ ×›-${formatNumber(builtArea)} ×"×¨`
              : "";
          })()}${data.buildingPermitNumber ? ` (×¢×¤"×™ ××“×™×“×” ××ª×•×š ×ª×›× ×™×ª ×”×™×ª×¨ ×‘× ×™×” ××¡' ${data.buildingPermitNumber} ××™×•× ${formatDateNumeric(data.buildingPermitDate || undefined)})` : ""}.</p>
          <p>${normalizeText(
            getValueFromPaths(data, [
              "extractedData.propertyLayoutDescription",
              "extractedData.property_layout_description",
              "extractedData.internal_layout",
              "extractedData.interior_analysis.description",
              "internalLayout",
            ]) ||
              (data.internalLayout as string) ||
              (data.extractedData as any)?.propertyLayoutDescription ||
              (data.extractedData as any)?.interior_analysis?.description,
            "×œ× ×¡×•×¤×§ ×ª×™××•×¨ ×œ×—×œ×•×§×” ×”×¤× ×™××™×ª",
          )}</p>
          <p>×¡×˜× ×“×¨×˜ ×”×’××¨ ×‘×“×™×¨×” ×‘×¨××” ${normalizeText(
            getValueFromPaths(data, [
              "extractedData.finishStandard",
              "extractedData.finish_standard",
              "extractedData.finishLevel",
              "finishStandard",
            ]) ||
              (data.extractedData as any)?.finishLevel ||
              (data.extractedData as any)?.finish_standard ||
              (data.extractedData as any)?.finishStandard,
            "×˜×•×‘×”",
          )} ×•×›×•×œ×œ, ×‘×™×Ÿ ×”×™×ª×¨: ${normalizeText(
            getValueFromPaths(data, [
              "extractedData.finishDetails",
              "extractedData.finish_details",
              "finishDetails",
            ]) ||
              (data.extractedData as any)?.finishDetails ||
              (data.extractedData as any)?.finish_details,
            "×¨×™×¦×•×£, ×—×œ×•× ×•×ª, ×“×œ×ª×•×ª, ××–×’×Ÿ, ×›×œ×™× ×¡× ×™×˜×¨×™×™× ×•×›×•'",
          )}.</p>
                </div>
        ${
          buildingMetrics.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×××¤×™×™× ×™ ×”××‘× ×”</div>
            <div class="info-grid">
              ${buildingMetrics
                .map(
                  (metric) =>
                    `<p><strong>${metric.label}:</strong> ${metric.value}</p>`,
                )
                .join("")}
                </div>
                </div>
              `
            : ""
        }
        ${
          sharedBuildingDescription ||
          sharedBuildingEntries.length ||
          sharedBuildingAddresses.length ||
          sharedBuildingNotes
            ? `
          <div class="section-block">
            <div class="sub-title">×¤×¨×˜×™ ×”×‘×™×ª ×”××©×•×ª×£</div>
            ${sharedBuildingDescription ? `<p>${sharedBuildingDescription}</p>` : ""}
            ${
              sharedBuildingEntries.length > 0
                ? `
              <ul class="bullet-list">
                ${sharedBuildingEntries.map((entry: string) => `<li>${entry}</li>`).join("")}
              </ul>
              `
                : ""
            }
            ${sharedBuildingAddresses.length > 0 ? `<p class="muted">×›×ª×•×‘×•×ª: ${sharedBuildingAddresses.join(" â€¢ ")}</p>` : ""}
            ${sharedBuildingNotes ? `<p class="muted">${sharedBuildingNotes}</p>` : ""}
            ${(() => {
              // Extract sub-chelka specific data from shared building sub_plots array
              const subPlots = toArray(
                sharedBuildingRaw?.sub_plots?.value ||
                  sharedBuildingData?.sub_plots ||
                  [],
              );
              const currentSubParcel = getSubParcelValue(data, landRegistry);
              const matchingSubPlot = subPlots.find(
                (sp: any) =>
                  sp?.sub_plot_number?.toString() ===
                    currentSubParcel?.toString() ||
                  sp?.sub_plot_number === currentSubParcel,
              );

              if (matchingSubPlot) {
                const parts: string[] = [];
                if (matchingSubPlot.area)
                  parts.push(`×©×˜×—: ${formatNumber(matchingSubPlot.area)} ×"×¨`);
                if (matchingSubPlot.description)
                  parts.push(
                    `×ª×™××•×¨: ${normalizeText(matchingSubPlot.description)}`,
                  );
                return parts.length > 0
                  ? `<p class="muted"><strong>×¤×¨×˜×™ ×ª×ª ×—×œ×§×”:</strong> ${parts.join(", ")}</p>`
                  : "";
              }
              return "";
            })()}
            </div>
                  `
            : ""
        }
        ${
          interiorNarrative
            ? `
          <div class="section-block">
            <div class="sub-title">× ×™×ª×•×— ×¤× ×™××™ ××¤×•×¨×˜</div>
            <div class="rich-text">${toRichHtml(interiorNarrative)}</div>
                </div>
              `
            : ""
        }
        ${
          facadeAssessment
            ? `
          <div class="section-block">
            <div class="sub-title">× ×™×ª×•×— ×—×–×™×ª ×”××‘× ×”</div>
            <div class="rich-text">${toRichHtml(facadeAssessment)}</div>
                    </div>
        `
            : ""
        }
        <!-- Interior Photos Grid -->
        ${
          interiorGallery.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×ª××•× ×•×ª ××•×¤×™×™× ×™×•×ª ×œ×”××—×©×”:</div>
            <div class="media-gallery">
              ${interiorGallery
                .filter(
                  (img: string) => img && img.trim() && img.trim().length > 0,
                )
                .slice(0, 6)
                .map(
                  (img: string, idx: number) => `
                <figure class="media-card">
                    <img src="${img}" alt="×ª××•× ×” ××•×¤×™×™× ×™×ª ${idx + 1}" data-managed-image="true" />
                </figure>
                  `,
                )
                .join("")}
                </div>
                </div>
              `
            : ""
        }
      </div>
      
      ${footerBlock}
    </section>
  `;

  // ===== CHAPTER 2 - Legal Status =====
  const extractedAttachmentsArray = Array.isArray(
    (data.extractedData as any)?.attachments,
  )
    ? (data.extractedData as any).attachments.map((att: any) => ({
        type: att?.description || att?.type,
        area: att?.area,
        color: att?.color,
        symbol: att?.symbol,
        sharedWith: att?.shared_with || att?.sharedWith,
      }))
    : [];
  const combinedAttachments = dedupeByKey(
    [...extractedAttachmentsArray, ...attachments],
    (item: any) => {
      return [
        item.type || "",
        item.area || "",
        item.color || "",
        item.symbol || "",
      ].join("|");
    },
  );

  const extractedOwnersArray = Array.isArray(
    (data.extractedData as any)?.owners,
  )
    ? (data.extractedData as any).owners.map((owner: any) => ({
        name: owner?.name || owner?.owner_name,
        idNumber: owner?.id_number || owner?.idNumber,
        share: owner?.ownership_share || owner?.share || "×©×œ××•×ª",
      }))
    : [];
  const combinedOwners = dedupeByKey(
    [...extractedOwnersArray, ...owners],
    (item: any) => {
      return [item.name || "", item.idNumber || "", item.share || ""].join("|");
    },
  );

  const extractedMortgagesArray = Array.isArray(
    (data.extractedData as any)?.mortgages,
  )
    ? (data.extractedData as any).mortgages.map((mortgage: any) => ({
        rank: mortgage?.rank || mortgage?.degree,
        share: mortgage?.fraction || mortgage?.share,
        amount: mortgage?.amount,
        lenders: mortgage?.lenders,
        borrowers: mortgage?.borrowers,
        registrationDate: mortgage?.date,
        essence: mortgage?.essence,
      }))
    : [];
  const combinedMortgages = dedupeByKey(
    [...extractedMortgagesArray, ...mortgages],
    (item: any) => {
      return [
        item.rank || "",
        item.lenders || "",
        item.registrationDate || "",
      ].join("|");
    },
  );

  const extractedNotesArray = Array.isArray((data.extractedData as any)?.notes)
    ? (data.extractedData as any).notes.map((note: any) => ({
        actionType: note?.action_type || note?.actionType,
        date: note?.date,
        beneficiary: note?.beneficiary,
        extra: note?.extra,
        isSubChelka: false,
      }))
    : [];
  const landRegistryNotesArray = toArray((landRegistry as any)?.notes).map(
    (note: any) => ({
      actionType: note?.action_type || note?.actionType,
      date: note?.date,
      beneficiary: note?.beneficiary,
      extra: note?.extra,
      isSubChelka: false,
    }),
  );

  // Sub-chelka specific notes
  const subChelkaNotes = {
    actionType:
      landRegistry?.sub_chelka_notes_action_type ||
      (data.extractedData as any)?.sub_chelka_notes_action_type,
    beneficiary:
      landRegistry?.sub_chelka_notes_beneficiary ||
      (data.extractedData as any)?.sub_chelka_notes_beneficiary,
    isSubChelka: true,
  };
  const subChelkaNotesArray =
    subChelkaNotes.actionType || subChelkaNotes.beneficiary
      ? [subChelkaNotes]
      : [];

  const combinedNotes = dedupeByKey(
    [...extractedNotesArray, ...landRegistryNotesArray, ...subChelkaNotesArray],
    (item) => {
      return [
        item.actionType || "",
        item.date || "",
        item.beneficiary || "",
        item.isSubChelka ? "sub" : "general",
      ].join("|");
    },
  );

  const registrarOffice = normalizeText(
    getValueFromPaths(data, [
      "extractedData.registrationOffice",
      "extractedData.registry_office",
      "extractedData.land_registry.registry_office",
      "extractedData.land_registry.registrationOffice",
      "land_registry.registration_office",
      "land_registry.registryOffice",
      "registryOffice",
    ]) ||
      landRegistry?.registration_office ||
      (data as any).land_registry?.registryOffice ||
      data.registryOffice,
    "â€”",
  );
  const extractDate = formatDateNumeric(
    getValueFromPaths(data, [
      "extractedData.extractDate",
      "extractedData.extract_date",
      "extractedData.land_registry.extractDate",
      "extractedData.land_registry.extract_date",
      "land_registry.extract_date",
      "land_registry.tabu_extract_date",
    ]) ||
      data.extractDate ||
      landRegistry?.tabu_extract_date ||
      landRegistry?.issue_date ||
      landRegistry?.registry_date,
  );
  const blockNum = formatNumber(
    getValueFromPaths(data, [
      "extractedData.gush",
      "extractedData.land_registry.gush",
      "land_registry.gush",
      "gush",
    ]) ||
      landRegistry?.gush ||
      data.gush,
  );
  const parcelNum = formatNumber(
    getValueFromPaths(data, [
      "extractedData.chelka",
      "extractedData.parcel",
      "extractedData.land_registry.chelka",
      "extractedData.land_registry.parcel",
      "land_registry.chelka",
      "parcel",
    ]) ||
      landRegistry?.chelka ||
      data.parcel,
  );
  const parcelAreaSqm = formatNumber(
    getValueFromPaths(data, [
      "extractedData.parcelArea",
      "extractedData.parcel_area",
      "extractedData.land_registry.parcelArea",
      "extractedData.land_registry.parcel_area",
      "extractedData.total_plot_area",
      "land_registry.total_plot_area",
      "parcelArea",
    ]) ||
      (data as any).parcelArea ||
      (data.extractedData as any)?.total_plot_area ||
      landRegistry?.total_plot_area,
  );
  const subParcelNum = formatNumber(getSubParcelValue(data, landRegistry));
  const registeredAreaSqm = formatNumber(
    getValueFromPaths(data, [
      "extractedData.registeredArea",
      "extractedData.registered_area",
      "extractedData.apartment_registered_area",
      "extractedData.land_registry.registeredArea",
      "extractedData.land_registry.registered_area",
      "extractedData.land_registry.apartment_registered_area",
      "land_registry.apartment_registered_area",
      "registeredArea",
    ]) ||
      (data as any).registeredArea ||
      data.extractedData?.apartment_registered_area ||
      landRegistry?.apartment_registered_area,
  );
  const sharedProperty = normalizeText(
    (data.extractedData as any)?.shared_property ||
      landRegistry?.shared_property,
    "â€”",
  );

  const sectionTwo = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter 2 Title -->
        <div class="chapter-title">2.&emsp;××¦×‘ ××©×¤×˜×™ â€“ ×”×–×›×•×™×•×ª ×‘× ×›×¡</div>
        <p>×œ×”×œ×Ÿ ×¡×§×™×¨×” ×ª××¦×™×ª×™×ª ×©×œ ×”××¦×‘ ×”××©×¤×˜×™ ×”×—×œ ×¢×œ ×”××§×¨×§×¢×™×Ÿ × ×©×•× ×—×•×•×ª ×”×“×¢×ª, ××©×¨ ××™× ×” ××”×•×•×” ×ª×—×œ×™×£ ×œ×¢×™×•×Ÿ ××§×™×£ ×‘××¡××›×™× ×”××©×¤×˜×™×™×.</p>
        
        <!-- Section 2.1 -->
        <div class="section-block">
          <div class="section-title">2.1&emsp;× ×¡×— ×¨×™×©×•× ××§×¨×§×¢×™×Ÿ</div>
          <p>×ª××¦×™×ª ××™×“×¢ ××¤× ×§×¡ ×”×–×›×•×™×•×ª ×”××ª× ×”×œ ×‘×œ×©×›×ª ×¨×™×©×•× ×”××§×¨×§×¢×™×Ÿ ${registrarOffice}, ××©×¨ ×”×•×¤×§ ×‘×××¦×¢×•×ª ××ª×¨ ×”××™× ×˜×¨× ×˜ ×©×œ ×¨×©× ×”××§×¨×§×¢×™×Ÿ ×‘××©×¨×“ ×”××©×¤×˜×™×, ×‘×ª××¨×™×š: ${extractDate}.</p>
          <p>×—×œ×§×” ${parcelNum} ×‘×’×•×© ${blockNum} ×‘×©×˜×— ×§×¨×§×¢ ×¨×©×•× ×©×œ ${parcelAreaSqm} ×"×¨.${(() => {
            const sharedParcels = getValueFromPaths(data, [
              "sharedParcels",
              "shared_parcels",
              "extractedData.sharedParcels",
              "land_registry.sharedParcels",
            ]);
            if (
              sharedParcels &&
              Array.isArray(sharedParcels) &&
              sharedParcels.length > 0
            ) {
              return ` ××©×•×ª×£ ×¢× ×—×œ×§×•×ª ${sharedParcels.join(", ")}.`;
            }
            return "";
          })()}</p>
          <div class="info-grid">
            <p><strong>×ª×ª-×—×œ×§×”:</strong> ${subParcelNum}</p>
            <p><strong>×§×•××”:</strong> ${normalizeText(landRegistry?.floor || data.floor?.toString(), "â€”")}</p>
            <p><strong>××¡×¤×¨ ××‘× ×”:</strong> ${normalizeText(buildingIdentifier, "â€”")}</p>
            <p><strong>×©×˜×— ×¨×©×•×:</strong> ${registeredAreaSqm} ×"×¨</p>
            <p><strong>×—×œ×§ ×‘×¨×›×•×© ××©×•×ª×£:</strong> ${sharedProperty}</p>
            ${landRegistry?.total_number_of_entries ? `<p><strong>××¡×¤×¨ ××’×¤×™×/×›× ×™×¡×•×ª:</strong> ${formatNumber(landRegistry?.total_number_of_entries)}</p>` : ""}
            ${landRegistry?.regulation_type ? `<p><strong>×ª×§× ×•×Ÿ:</strong> ${normalizeText(landRegistry?.regulation_type)}</p>` : ""}
            ${landRegistry?.rights ? `<p><strong>×–×›×•×™×•×ª:</strong> ${normalizeText(landRegistry?.rights)}</p>` : ""}
            ${landRegistry?.address_from_tabu ? `<p><strong>×›×ª×•×‘×ª (××”× ×¡×—):</strong> ${normalizeText(landRegistry?.address_from_tabu)}</p>` : ""}
                          </div>
        </div>
        ${
          combinedAttachments.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×”×¦××“×•×ª</div>
            <ul class="legal-list">
              ${combinedAttachments
                .map(
                  (att: any) => `
                <li>${normalizeText(att.type)}${att.area ? ` ×‘×©×˜×— ${formatNumber(att.area)} ×"×¨` : ""}${att.symbol ? `, ×”××¡×•×× /×ª ×‘×ª×©×¨×™×˜ ×‘××•×ª ${att.symbol}` : ""}${att.color ? `, ×‘×¦×‘×¢ ${att.color}` : ""}${att.sharedWith ? `, ××©×•×ª×¤×ª ×¢×: ${normalizeText(att.sharedWith)}` : ""}.</li>
                        `,
                )
                .join("")}
            </ul>
                      </div>
        `
            : ""
        }
        ${
          additionalAreas.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×©×˜×—×™× × ×•×¡×¤×™×</div>
            <ul class="legal-list">
              ${additionalAreas
                .map(
                  (area: any) => `
                <li>${normalizeText(area.type)}${area.area ? ` ×‘×©×˜×— ${formatNumber(area.area)} ×"×¨` : ""}.</li>
              `,
                )
                .join("")}
            </ul>
                    </div>
        `
            : ""
        }
        ${
          combinedOwners.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×‘×¢×œ×•×™×•×ª</div>
            <ul class="legal-list">
              ${combinedOwners
                .map(
                  (owner: any) => `
                <li>${normalizeText(owner.name)}${owner.idNumber ? `, ×ª.×– ${owner.idNumber}` : ""}, ×—×œ×§ ×‘× ×›×¡ â€“ ${normalizeText(owner.share, "×©×œ××•×ª")}.</li>
              `,
                )
                .join("")}
            </ul>
            </div>
        `
            : `<p>×‘×¢×œ×•×™×•×ª: ${formatOwnership(data)}</p>`
        }
        ${
          combinedMortgages.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">××©×›× ×ª××•×ª</div>
            <ul class="legal-list">
              ${combinedMortgages
                .map(
                  (mortgage: any) => `
                <li>××©×›× ×ª× ××“×¨×’×” ${normalizeText(mortgage.rank, "â€”")} ×œ×˜×•×‘×ª ${normalizeText(mortgage.lenders)}${mortgage.amount ? ` ×¢×œ ×¡×š â‚ª${formatNumber(mortgage.amount)}` : ""}${mortgage.registrationDate ? `, ××™×•× ${formatDateNumeric(mortgage.registrationDate)}` : ""}${mortgage.share ? `, ×—×œ×§ ×‘× ×›×¡: ${normalizeText(mortgage.share)}` : ""}.</li>
              `,
                )
                .join("")}
            </ul>
                </div>
              `
            : ""
        }
        ${
          combinedNotes.length > 0
            ? `
          <div class="section-block">
            <div class="sub-title">×”×¢×¨×•×ª${combinedNotes.some((n) => n.isSubChelka) ? " - ×”×¢×¨×•×ª ×œ×ª×ª ×—×œ×§×” ×•×”×¢×¨×•×ª ×›×œ×œ×™×•×ª" : ""}</div>
            <ul class="legal-list">
              ${combinedNotes
                .map((note) => {
                  const prefix = note.isSubChelka
                    ? "<strong>×”×¢×¨×•×ª ×œ×ª×ª ×—×œ×§×”:</strong> "
                    : "";
                  return `<li>${prefix}${normalizeText(note.actionType)}${note.date ? ` ××™×•× ${formatDateNumeric(note.date)}` : ""}${note.beneficiary ? ` ×œ×˜×•×‘×ª ${normalizeText(note.beneficiary)}` : ""}${note.extra ? `, ${normalizeText(note.extra)}` : ""}.</li>`;
                })
                .join("")}
            </ul>
            </div>
        `
            : ""
        }
        ${
          (data.extractedData as any)?.plot_notes || data.notes
            ? `
          <div class="callout section-block">
            ${(data.extractedData as any)?.plot_notes || data.notes}
          </div>
        `
            : ""
        }
        ${
          sharedBuildingDescription ||
          sharedBuildingEntries.length ||
          sharedBuildingAddresses.length ||
          sharedBuildingNotes
            ? `
          <div class="section-block">
            <div class="section-title">2.2&emsp;××¡××›×™ ×”×‘×™×ª ×”××©×•×ª×£</div>
            <p>${sharedBuildingParagraph}</p>
            ${
              sharedBuildingEntries.length > 0
                ? `
              <ul class="legal-list">
                ${sharedBuildingEntries.map((entry: string) => `<li>${entry}</li>`).join("")}
              </ul>
            `
                : ""
            }
            ${sharedBuildingAddresses.length > 0 ? `<p class="muted">×›×ª×•×‘×•×ª: ${sharedBuildingAddresses.join(" â€¢ ")}</p>` : ""}
            ${sharedBuildingNotes ? `<p class="muted">${sharedBuildingNotes}</p>` : ""}
          </div>
        `
            : ""
        }
        <div class="section-block">
          <div class="section-title">2.3&emsp;×”×¡×ª×™×™×’×•×ª</div>
          <p>${LOCKED_HEBREW_TEXT.legalDisclaimer}</p>
        </div>
        ${
          landRegistry?.easements_description ||
          landRegistry?.easements_essence ||
          landRegistry?.sub_parcel_easements_essence ||
          landRegistry?.sub_parcel_easements_description
            ? `
          <div class="callout section-block">
            ${
              landRegistry?.easements_description ||
              landRegistry?.easements_essence
                ? `
              <div style="margin-bottom: 8px;">
                <strong>×–×™×§×•×ª ×”× ××” ×œ×›×œ ×”×—×œ×§×”:</strong> ${normalizeText(landRegistry?.easements_description || landRegistry?.easements_essence)}
              </div>
            `
                : ""
            }
            ${
              landRegistry?.sub_parcel_easements_essence ||
              landRegistry?.sub_parcel_easements_description
                ? `
              <div>
                <strong>×–×™×§×•×ª ×”× ××” ×œ×ª×ª ×”×—×œ×§×”:</strong> ${normalizeText(landRegistry?.sub_parcel_easements_description || landRegistry?.sub_parcel_easements_essence)}
              </div>
            `
                : ""
            }
          </div>
        `
            : ""
        }
        ${
          buildingPermitRows.length > 0
            ? `
          <table class="table details-table">
            <tbody>
              ${buildingPermitRows
                .map(
                  (row) => `
                  <tr>
                    <th>${row.label}</th>
                    <td>${row.value}</td>
                  </tr>
                `,
                )
                .join("")}
            </tbody>
          </table>
        `
            : ""
        }
          </div>
      
      ${footerBlock}
      </section>
  `;

  // ===== CHAPTER 3 - Planning & Licensing =====
  // Extract planning rights from multiple potential sources
  const planningRights =
    (data as any).planningRights ||
    (data.extractedData as any)?.planning_rights ||
    (data.extractedData as any)?.planningRights ||
    (data.extractedData as any)?.building_rights ||
    (data.extractedData as any)?.buildingRights ||
    {};

  const planningSection = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter 3 Title -->
        <div class="chapter-title">3.&emsp;××™×“×¢ ×ª×›× ×•× ×™/ ×¨×™×©×•×™ ×‘× ×™×”</div>
        <p>×”××™×“×¢ ××‘×•×¡×¡ ×¢×œ ××™×“×¢ ×××¢×¨×›×ª ×”××™×“×¢ ×”×ª×›× ×•× ×™ ×©×œ ×”×•×•×¢×“×” ×”××§×•××™×ª ×œ×ª×›× ×•×Ÿ ×•×œ×‘× ×™×”, ××™×“×¢ ×××ª×¨×™ ×”××™× ×˜×¨× ×˜ ×©×œ ×¨×©×•×ª ××§×¨×§×¢×™ ×™×©×¨××œ ×•××©×¨×“ ×”×¤× ×™× ×•×›×Ÿ ××™×“×¢ ×”×§×™×™× ×‘××©×¨×“× ×•.</p>
        
        <!-- Section 3.1 -->
        <div class="section-title">3.1&emsp;×¨×™×›×•×– ×ª×›× ×™×•×ª ×‘× ×™×™×Ÿ ×¢×™×¨ ×¨×œ×‘× ×˜×™×•×ª ×‘×ª×•×§×£</div>
        ${
          planningPlans.length >= 4
            ? `
          <table class="table">
                <thead>
              <tr>
                <th>××”×•×ª</th>
                <th>××¡×¤×¨ ×ª×›× ×™×ª</th>
                <th>×™.×¤.</th>
                <th>×ª××¨×™×š ×¤×¨×¡×•×</th>
                  </tr>
                </thead>
                <tbody>
              ${planningPlans
                .map(
                  (plan: any) => `
                <tr>
                  <td>${plan.plan_name || plan.name || plan.nature || plan.description || plan.mehut || "×ª×›× ×™×ª ×‘× ×™×™×Ÿ ×¢×™×¨"}</td>
                  <td>${plan.plan_number || plan.planNumber || "N/A"}</td>
                  <td>${plan.yp || plan.gazette_number || plan.gazetteNumber || "â€”"}</td>
                  <td>${plan.publication_date || plan.publicationDate || "N/A"}</td>
                    </tr>
                  `,
                )
                .join("")}
                </tbody>
              </table>
            `
            : planningPlans.length > 0
              ? `
          <table class="table">
                <thead>
              <tr>
                <th>××”×•×ª</th>
                <th>××¡×¤×¨ ×ª×›× ×™×ª</th>
                <th>×™.×¤.</th>
                <th>×ª××¨×™×š ×¤×¨×¡×•×</th>
                  </tr>
                </thead>
                <tbody>
              ${planningPlans
                .map(
                  (plan: any) => `
                <tr>
                  <td>${plan.plan_name || plan.name || plan.nature || plan.description || plan.mehut || "×ª×›× ×™×ª ×‘× ×™×™×Ÿ ×¢×™×¨"}</td>
                  <td>${plan.plan_number || plan.planNumber || "N/A"}</td>
                  <td>${plan.yp || plan.gazette_number || plan.gazetteNumber || "â€”"}</td>
                  <td>${plan.publication_date || plan.publicationDate || "N/A"}</td>
                    </tr>
                  `,
                )
                .join("")}
                </tbody>
              </table>
              <p style="color: #dc2626; font-weight: 600; margin-top: 1rem;">âš ï¸ × ×“×¨×© ××™×œ×•×™ ××™× ×™××•× 4 ×ª×•×›× ×™×•×ª ×œ×¤× ×™ ×™×™×¦×•× ×”×“×•×—</p>
            `
              : `
          <p style="color: #dc2626; font-weight: 600;">âš ï¸ × ×“×¨×© ××™×œ×•×™ ××™× ×™××•× 4 ×ª×•×›× ×™×•×ª ×œ×¤× ×™ ×™×™×¦×•× ×”×“×•×—</p>
        `
        }
        
        <div class="section-title">3.2&emsp;×¨×™×›×•×– ×–×›×•×™×•×ª ×”×‘× ×™×”</div>
                <div>
          ${
            planningRights && Object.keys(planningRights).length > 0
              ? `
            <ul style="list-style: none; padding-right: 0;">
              <li><strong>×™×¢×•×“:</strong> ${normalizeText(planningRights.usage || planningRights.usageType || planningRights.yiud || planningRights.yiudType, "â€”")}</li>
              <li><strong>×©×˜×— ××’×¨×© ××™× ×™××œ×™:</strong> ${normalizeText(planningRights.minLotSize || planningRights.min_lot_size || planningRights.minimumLotSize, "â€”")} ×"×¨</li>
              <li><strong>××—×•×–×™ ×‘× ×™×™×”:</strong> ${normalizeText(planningRights.buildPercentage || planningRights.build_percentage || planningRights.buildingPercentage, "â€”")}%</li>
              <li><strong>××¡×¤×¨ ×§×•××•×ª ××•×ª×¨×•×ª:</strong> ${normalizeText(planningRights.maxFloors || planningRights.max_floors || planningRights.floors || planningRights.maxFloorsAllowed, "â€”")}</li>
              <li><strong>××¡×¤×¨ ×™×—×™×“×•×ª ×“×™×•×¨:</strong> ${normalizeText(planningRights.maxUnits || planningRights.max_units || planningRights.units || planningRights.maxUnitsAllowed, "â€”")}</li>
              <li><strong>×§×•×•×™ ×‘× ×™×™×Ÿ:</strong> ${normalizeText(planningRights.buildingLines || planningRights.building_lines || planningRights.setbackLines || planningRights.setback_lines, "â€”")}</li>
            </ul>
          `
              : `<p style="color: #dc2626;">âš ï¸ × ×“×¨×© ××™×œ×•×™ ×–×›×•×™×•×ª ×‘× ×™×™×” (6 ×©×“×•×ª ×—×•×‘×”)</p>`
          }
              </div>
              
        <div class="section-title">3.3&emsp;×¨×™×©×•×™ ×‘× ×™×”</div>
        <p>××¢×™×•×Ÿ ×‘×ª×™×§ ×”×‘× ×™×™×Ÿ ×”×¡×¨×•×§ ×‘×•×•×¢×“×” ×”××§×•××™×ª ×œ×ª×›× ×•×Ÿ ×•×œ×‘× ×™×” ${normalizeText(data.city)}, ××•×ª×¨×• ×”××¡××›×™× ×”×¨×œ×‘× ×˜×™×™× ×”×‘××™×:</p>
        ${(() => {
          const permits: Array<{
            number: string;
            date: string;
            description: string;
          }> = [];
          if (data.buildingPermitNumber) {
            // Use specific permit description field, not the generic building description
            const permitDesc =
              (data as any).permitDescription ||
              (data.extractedData as any)?.permit_description ||
              (data.extractedData as any)?.permitDescription ||
              (data as any).building_permit?.description;

            // Use permitDesc if available, otherwise use standard permit description (not buildingDescription which is project-level)
            const finalPermitDesc =
              permitDesc ||
              "×œ×”×§×™× ×‘× ×™×™×Ÿ ××’×•×¨×™× ×‘×Ÿ 15 ×§×•××•×ª ×¢×œ ×’×‘×™ ×¢××•×“×™× ×•-2 ×§×•××•×ª ××¨×ª×¤×™ ×—× ×™×”, ×”××›×™×œ 55 ×“×™×¨×•×ª";

            permits.push({
              number: data.buildingPermitNumber,
              date: formatDateNumeric(data.buildingPermitDate || undefined),
              description: normalizeText(finalPermitDesc, "â€”"),
            });
          }
          if ((data as any).buildingPermitNumber2) {
            permits.push({
              number: (data as any).buildingPermitNumber2,
              date: formatDateNumeric(
                (data as any).buildingPermitDate2 || undefined,
              ),
              description: normalizeText(
                (data as any).buildingDescription2,
                "â€”",
              ),
            });
          }
          // Sort by date (newest first)
          permits.sort((a, b) => {
            const dateA = new Date(
              a.date.split(".").reverse().join("-"),
            ).getTime();
            const dateB = new Date(
              b.date.split(".").reverse().join("-"),
            ).getTime();
            return dateB - dateA;
          });
          return permits
            .map(
              (p) =>
                `<p>â€¢ ×”×™×ª×¨ ×‘× ×™×” ××¡' ${p.number} ××™×•× ${p.date}, ${p.description}.</p>`,
            )
            .join("");
        })()}
        ${(() => {
          const hasCompletionCert = getValueFromPaths(data, [
            "completionCertificate",
            "completion_certificate",
            "hasCompletionCert",
          ]);
          if (!hasCompletionCert) {
            return "<p>â€¢ ×œ× ××•×ª×¨ ×˜×•×¤×¡ 4 / ×ª×¢×•×“×ª ×’××¨ ×©×œ ×”×‘× ×™×™×Ÿ.</p>";
          }
          return "";
        })()}
        ${
          buildingPermitRows.length > 0
            ? `
          <table class="table details-table">
            <tbody>
              ${buildingPermitRows
                .map(
                  (row) => `
                  <tr>
                    <th>${row.label}</th>
                    <td>${row.value}</td>
                  </tr>
                `,
                )
                .join("")}
            </tbody>
          </table>
              `
            : ""
        }
        ${(() => {
          // Support both legacy pngExport and new garmushkaRecords format
          const garmushka = data.garmushkaMeasurements as any;
          const garmushkaRecords = garmushka?.garmushkaRecords || [];
          const legacyPngExport = garmushka?.pngExport;
          const legacyPngExports = garmushka?.pngExports || [];

          // Collect all available garmushka images
          const allImages: string[] = [];

          // Add from garmushkaRecords (new format - uploaded files)
          garmushkaRecords.forEach((record: any) => {
            if (
              record?.url &&
              typeof record.url === "string" &&
              record.url.trim()
            ) {
              allImages.push(record.url.trim());
            }
          });

          // Add legacy pngExports array
          legacyPngExports.forEach((url: string) => {
            if (
              url &&
              typeof url === "string" &&
              url.trim() &&
              !allImages.includes(url.trim())
            ) {
              allImages.push(url.trim());
            }
          });

          // Add legacy single pngExport
          if (
            legacyPngExport &&
            typeof legacyPngExport === "string" &&
            legacyPngExport.trim() &&
            !allImages.includes(legacyPngExport.trim())
          ) {
            allImages.push(legacyPngExport.trim());
          }

          if (allImages.length === 0) return "";

          return `
            <div class="section-block" style="margin-top: 20px;">
              <div class="sub-title">×ª×©×¨×™×˜ ×”×“×™×¨×” ××ª×•×š ×ª×›× ×™×ª ×”×”×™×ª×¨:</div>
              ${allImages
                .map(
                  (imgUrl, idx) => `
                <figure class="garmushka-card">
                  <img src="${imgUrl}" alt="×ª×©×¨×™×˜ ${idx + 1}" data-managed-image="true" />
                  <figcaption class="media-caption">×ª×©×¨×™×˜ ${idx + 1}${allImages.length > 1 ? ` ××ª×•×š ${allImages.length}` : ""}</figcaption>
          </figure>
              `,
                )
                .join("")}
            </div>
          `;
        })()}

        <div class="section-title">3.4&emsp;××™×›×•×ª ×¡×‘×™×‘×”</div>
        ${
          (data as any).landContamination && (data as any).landContaminationNote
            ? `
          <p>${LOCKED_HEBREW_TEXT.contaminationAlternate.replace("{{contamination_note}}", normalizeText((data as any).landContaminationNote))}</p>
        `
            : `
          <p>${LOCKED_HEBREW_TEXT.contaminationDefault}</p>
        `
        }
                </div>
      
      ${footerBlock}
    </section>
  `;

  // ===== CHAPTER 4 - Factors & Considerations =====
  const considerationsSection = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter 4 Title -->
        <div class="chapter-title">4.&emsp;×’×•×¨××™× ×•×©×™×§×•×œ×™× ×‘××•××“×Ÿ ×”×©×•×•×™</div>
        <p>${LOCKED_HEBREW_TEXT.considerationsIntro}</p>
        
        <!-- Environment & Property -->
        <div class="section-block">
          <div class="sub-title">×”×¡×‘×™×‘×” ×•×”× ×›×¡</div>
          <ul class="bullet-list">
            <li>××™×§×•× ×”× ×›×¡ ×‘${address}.</li>
            <li>× ×©×•× ×—×•×•×ª ×”×“×¢×ª: ${data.propertyEssence || "×“×™×¨×ª ××’×•×¨×™×"} ${formatFloor(data.floor)}.</li>
            ${(() => {
              // Include measured area from Garmushka if available
              // Try apartmentSqm first, then calculate from measurementTable
              let measuredArea = (data as any).apartmentSqm;

              // Fallback: calculate from garmushkaMeasurements.measurementTable
              if (
                !measuredArea &&
                (data as any).garmushkaMeasurements?.measurementTable
              ) {
                const table = (data as any).garmushkaMeasurements
                  .measurementTable;
                measuredArea = table
                  .filter(
                    (m: any) => m && m.type === "polygon" && m.measurement,
                  )
                  .reduce((sum: number, m: any) => {
                    const match = m.measurement.match(/([\d.,]+)\s*m[Â²2]?/i);
                    if (match) {
                      const numStr = match[1].replace(",", ".");
                      const parsed = parseFloat(numStr);
                      return sum + (isFinite(parsed) ? parsed : 0);
                    }
                    return sum;
                  }, 0);
              }

              const registeredArea = getValueFromPaths(data, [
                "extractedData.registeredArea",
                "extractedData.registered_area",
                "extractedData.apartment_registered_area",
                "registeredArea",
              ]);

              if (measuredArea && measuredArea > 0) {
                const areaText = `×©×˜×— ×”×“×™×¨×” ×œ×¤×™ ××“×™×“×”: ${formatNumber(measuredArea)} ×"×¨`;
                const regAreaText = registeredArea
                  ? ` (×©×˜×— ×¨×©×•×: ${formatNumber(registeredArea)} ×"×¨)`
                  : "";
                return `<li>${areaText}${regAreaText}, ×”×—×œ×•×§×” ×”×¤×•× ×§×¦×™×•× ××œ×™×ª ×•×¨××ª ×”×’××¨ (×”×›×œ ×›××¤×•×¨×˜ ×œ×¢×™×œ).</li>`;
              }
              return `<li>×©×˜×— ×”×“×™×¨×”, ×”×—×œ×•×§×” ×”×¤×•× ×§×¦×™×•× ××œ×™×ª ×•×¨××ª ×”×’××¨ (×”×›×œ ×›××¤×•×¨×˜ ×œ×¢×™×œ).</li>`;
            })()}
          </ul>
        </div>
        
        <!-- Rights Status -->
        <div class="section-block">
          <div class="sub-title">××¦×‘ ×”×–×›×•×™×•×ª</div>
          <ul class="bullet-list">
            <li>×”×–×›×•×™×•×ª ×‘× ×›×¡ â€“ ${formatOwnership(data)}.</li>
            <li>×‘×”×ª×× ×œ×ª×©×¨×™×˜ ×”×‘×™×ª ×”××©×•×ª×£ ×”×“×™×¨×” ×–×•×”×ª×” ×›×ª×ª ×—×œ×§×” ${formatNumber(getSubParcelValue(data, landRegistry))} ×‘×§×•××” ${normalizeText(data.floor?.toString(), "â€”")}${typeof data.airDirections === "string" && data.airDirections.trim() ? ` ×”×¤×•× ×” ×œ×›×™×•×•× ×™× ${data.airDirections.trim()}` : ""}.</li>
          </ul>
              </div>
        
        <!-- Planning & Licensing -->
        <div class="section-block">
          <div class="sub-title">××¦×‘ ×ª×›× ×•× ×™ ×•×¨×™×©×•×™</div>
          <ul class="bullet-list">
            <li>×–×›×•×™×•×ª ×”×‘× ×™×” ×•××¤×©×¨×•×™×•×ª ×”× ×™×¦×•×œ ×¢×¤"×™ ×ª×›× ×™×•×ª ×‘× ×™×™×Ÿ ×¢×™×¨ ×‘×ª×•×§×£.</li>
            <li>×”×‘× ×™×” ×‘×¤×•×¢×œ ×ª×•×××ª ××ª ×”×™×ª×¨ ×”×‘× ×™×”.</li>
          </ul>
            </div>
        
        <!-- Valuation -->
        <div class="section-block">
          <div class="sub-title">××•××“×Ÿ ×”×©×•×•×™</div>
          <ul class="bullet-list">
            <li>×”× ×›×¡ ×”×•×¢×¨×š ×‘×’×™×©×ª ×”×”×©×•×•××”, ×‘×”×ª×‘×¡×¡ ×¢×œ ×¨××ª ××—×™×¨×™ × ×›×¡×™× ×“×•××™× ×ª×•×š ×‘×™×¦×•×¢ ×”×ª×××•×ª ×œ× ×›×¡ × ×©×•× ×—×•×•×ª ×”×“×¢×ª, × ×›×•×Ÿ ×œ××•×¢×“ ×”×‘×™×§×•×¨ ×‘× ×›×¡.</li>
            <li>×”××—×™×¨×™× ×”××¤×•×¨×˜×™× ×‘×©×•××” ×›×•×œ×œ×™× ××¢"× ×›× ×”×•×’ ×‘× ×›×¡×™× ××¡×•×’ ×–×”.</li>
            <li>×”×–×›×•×™×•×ª ×‘× ×›×¡ ×”×•×¢×¨×›×• ×›×—×•×¤×©×™×•×ª ××›×œ ×—×•×‘, ×©×¢×‘×•×“ ××• ××—×–×™×§.</li>
              </ul>
            </div>
          </div>
      
      ${footerBlock}
      </section>
  `;

  // ===== CHAPTER 5 - Calculations =====
  const comparablesList =
    (data as any).comparableData || (data as any).comparable_data || [];
  const includedComps = comparablesList.filter(
    (c: any) => c.included !== false,
  );

  // Extract analysis data from comparable data analysis results
  // Priority: comparableDataAnalysis (from Step4) > comparableAnalysis > marketAnalysis
  const analysisData =
    (data as any).comparableDataAnalysis ||
    (data as any).comparableAnalysis ||
    (data as any).marketAnalysis ||
    {};
  // Parse all numeric values safely (handles strings from backend)
  const averagePrice = parseNumeric(analysisData.averagePrice);
  const medianPrice = parseNumeric(analysisData.medianPrice);
  const averagePricePerSqm = parseNumeric(analysisData.averagePricePerSqm);
  const medianPricePerSqm = parseNumeric(analysisData.medianPricePerSqm);

  // Use the final price per sqm (prioritize data.pricePerSqm if > 0, then analysisData values)
  // Check multiple sources to ensure we get a valid value
  const topLevelPricePerSqm = parseNumeric((data as any).pricePerSqm);
  const equivPricePerSqmRaw =
    topLevelPricePerSqm > 0
      ? topLevelPricePerSqm
      : averagePricePerSqm ||
        medianPricePerSqm ||
        (data as any).comparableDataAnalysis?.averagePricePerSqm ||
        ((data as any).comparableAnalysis as any)?.averagePricePerSqm ||
        (data as any).marketAnalysis?.averagePricePerSqm ||
        ((data as any).comparableDataAnalysis?.section52 as any)
          ?.final_price_per_sqm ||
        0;
  const equivPricePerSqm = parseNumeric(equivPricePerSqmRaw);

  // Debug logging (only in development)
  if (process.env.NODE_ENV === "development") {
    console.log("ğŸ“Š [Document Template] Price Per Sqm Sources:", {
      topLevelPricePerSqm,
      averagePricePerSqm,
      medianPricePerSqm,
      comparableDataAnalysisAvg: (data as any).comparableDataAnalysis
        ?.averagePricePerSqm,
      comparableAnalysisAvg: ((data as any).comparableAnalysis as any)
        ?.averagePricePerSqm,
      marketAnalysisAvg: (data as any).marketAnalysis?.averagePricePerSqm,
      section52Price: ((data as any).comparableDataAnalysis?.section52 as any)
        ?.final_price_per_sqm,
      equivPricePerSqm,
    });
  }

  const valuationSection = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter 5 Title -->
        <div class="chapter-title">5.&emsp;×ª×—×©×™×‘×™× ×œ××•××“×Ÿ ×”×©×•×•×™</div>
        
        <!-- Section 5.1 -->
        <div class="section-title">5.1&emsp;× ×ª×•× ×™ ×”×©×•×•××”</div>
        <p>${LOCKED_HEBREW_TEXT.comparablesIntro.replace("{{city}}", normalizeText(data.city, "â€”"))}</p>
        
        ${
          includedComps.length >= 3
            ? `
          <div class="section-block comparables-table-block">
            <div class="comparables-table">
              ${createComparablesTable(data)}
              <p class="muted">* ××•×¦×’×•×ª ${includedComps.length} ×¢×¡×§××•×ª ×›×œ×•×œ×•×ª ××ª×•×š ${comparablesList.length} ×©× ×‘×“×§×•</p>
            </div>
            
            ${
              averagePrice > 0 ||
              medianPrice > 0 ||
              averagePricePerSqm > 0 ||
              medianPricePerSqm > 0
                ? `
              <div class="section-block" style="margin-top: 16px; padding: 12px; background: rgba(59, 130, 246, 0.08); border-radius: 12px;">
                <div class="sub-title" style="font-size: 11pt; margin: 0 0 12px 0;">× ×™×ª×•×— ×¡×˜×˜×™×¡×˜×™ ×©×œ ×”×¢×¡×§××•×ª</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 10pt;">
                  ${
                    averagePrice > 0
                      ? `
                    <div>
                      <strong style="color: #1e40af;">××—×™×¨ ×××•×¦×¢:</strong>
                      <div style="font-size: 11pt; font-weight: 600; color: #1e3a8a;">${formatCurrency(averagePrice)}</div>
                    </div>
                  `
                      : ""
                  }
                  ${
                    medianPrice > 0
                      ? `
                    <div>
                      <strong style="color: #1e40af;">××—×™×¨ ×—×¦×™×•× ×™:</strong>
                      <div style="font-size: 11pt; font-weight: 600; color: #1e3a8a;">${formatCurrency(medianPrice)}</div>
                    </div>
                  `
                      : ""
                  }
                  ${
                    averagePricePerSqm > 0
                      ? `
                    <div>
                      <strong style="color: #1e40af;">×××•×¦×¢ ×œ×"×¨:</strong>
                      <div style="font-size: 11pt; font-weight: 600; color: #059669;">${formatCurrency(averagePricePerSqm)}</div>
                    </div>
                  `
                      : ""
                  }
                  ${
                    medianPricePerSqm > 0
                      ? `
                    <div>
                      <strong style="color: #1e40af;">×—×¦×™×•×Ÿ ×œ×"×¨:</strong>
                      <div style="font-size: 11pt; font-weight: 600; color: #059669;">${formatCurrency(medianPricePerSqm)}</div>
                    </div>
                  `
                      : ""
                  }
                </div>
                ${
                  analysisData.priceRange
                    ? `
                  <p class="muted" style="margin-top: 12px; font-size: 9pt;">
                    ×˜×•×•×— ××—×™×¨×™×: ${formatCurrency(parseNumeric(analysisData.priceRange.min))} - ${formatCurrency(parseNumeric(analysisData.priceRange.max))}
                  </p>
                `
                    : ""
                }
              </div>
            `
                : ""
            }
          </div>
        `
            : `
          <p style="color: #dc2626; font-weight: 600;">âš ï¸ × ×“×¨×©×•×ª ××™× ×™××•× 3 ×¢×¡×§××•×ª ×”×©×•×•××” ×œ×—×™×©×•×‘ ×©×•×•×™</p>
        `
        }
        
        <!-- Section 5.2 -->
        <div class="section-title">5.2&emsp;×ª×—×©×™×‘ ×©×•×•×™ ×”× ×›×¡</div>
        <div class="section-block">
          <p>×‘×©×™× ×œ×‘ ×œ× ×ª×•× ×™ ×”×”×©×•×•××” ×©×œ×¢×™×œ, ×ª×•×š ×›×“×™ ×‘×™×¦×•×¢ ×”×ª×××•×ª × ×“×¨×©×•×ª ×œ× ×›×¡ × ×©×•× ×”×©×•××”, ×©×•×•×™ ×"×¨ ×‘× ×•×™ ×œ× ×›×¡ × ×©×•× ×”×©×•××” ×‘×’×‘×•×œ×•×ª ${formatNumber(equivPricePerSqm)} â‚ª.</p>

          ${(() => {
            const balconyAreaValue = Number(
              (data.extractedData as any)?.balconyArea ||
                (data as any).balconyArea ||
                0,
            );
            const hasBalcony = balconyAreaValue > 0;
            return `
          <table class="table">
                  <thead>
            <tr>
              <th>×ª×™××•×¨ ×”× ×›×¡</th>
              <th>×©×˜×— ×“×™×¨×” ×‘×"×¨</th>
              ${hasBalcony ? "<th>××¨×¤×¡×ª</th>" : ""}
              <th>×"×¨ ××§×•'</th>
              <th>×©×•×•×™ ×"×¨ ×‘× ×•×™</th>
              <th>×¡×”"×› ×©×•×•×™ ×”× ×›×¡</th>
                    </tr>
                  </thead>
                  <tbody>
            <tr>
              <td>${normalizeText(data.propertyEssence, "×“×™×¨×ª ××’×•×¨×™×")} ${data.rooms ? `${data.rooms} ×—'` : ""}, ×‘×§×•××” ${data.floor || "â€”"} ×‘×›×ª×•×‘×ª ${normalizeText(data.street)} ${data.buildingNumber || ""}${data.neighborhood ? `, ×©×›×•× ×ª ${data.neighborhood}` : ""}${data.city ? `, ${data.city}` : ""}</td>
              <td>${formatNumber(registeredAreaSqm || data.extractedData?.builtArea || data.builtArea)}</td>
              ${hasBalcony ? `<td>${formatNumber(balconyAreaValue)}</td>` : ""}
              <td>${(() => {
                // Equivalent Area = Apartment Area (registered, NOT built) + Balcony * 0.5
                const apartmentArea = Number(
                  registeredAreaSqm ||
                    (data as any).registeredArea ||
                    data.extractedData?.apartment_registered_area ||
                    0,
                );
                if (!apartmentArea) return "â€”";
                return Math.round(apartmentArea + balconyAreaValue * 0.5);
              })()}</td>
              <td>${formatNumber(equivPricePerSqm)} â‚ª</td>
              <td>${(() => {
                // Calculate total value dynamically: equivalent area * price per sqm
                const apartmentArea = Number(
                  registeredAreaSqm ||
                    (data as any).registeredArea ||
                    data.extractedData?.apartment_registered_area ||
                    0,
                );
                const equivalentArea = Math.round(
                  apartmentArea + balconyAreaValue * 0.5,
                );
                const calculatedValue = equivalentArea * equivPricePerSqm;
                return formatNumber(calculatedValue) + " â‚ª";
              })()}</td>
                      </tr>
              </tbody>
            </table>
          `;
          })()}
          <p style="margin-top: 12px;">×”×©×•×•×™ ×›×•×œ×œ ××¢"×.</p>
        </div>
      </div>
      
      ${footerBlock}
      </section>
  `;

  // ===== CHAPTER 6 - Final Valuation & Signature =====
  // Calculate final value dynamically: equivalent area * price per sqm
  const calculatedApartmentArea = Number(
    registeredAreaSqm ||
      (data as any).registeredArea ||
      data.extractedData?.apartment_registered_area ||
      0,
  );
  const calculatedBalcony = Number(
    (data.extractedData as any)?.balconyArea || (data as any).balconyArea || 0,
  );
  const calculatedEquivalentArea = Math.round(
    calculatedApartmentArea + calculatedBalcony * 0.5,
  );
  const calculatedFinalValue = calculatedEquivalentArea * equivPricePerSqm;
  // Use calculated value if valid, otherwise fall back to stored finalValue
  const displayFinalValue =
    calculatedFinalValue > 0 ? calculatedFinalValue : finalValue;
  const finalValueText = numberToHebrewWords(displayFinalValue);

  const summarySection = `
    <section class="page">
        ${pageHeader}
      
      <div class="page-body">
        <!-- Chapter 6 Title -->
        <div class="chapter-title">6.&emsp;×”×©×•××”</div>
        
        <!-- Final Valuation Statement -->
        <div class="section-block">
            <p>×‘×©×™× ×œ×‘ ×œ××™×§×•××• ×©×œ ×”× ×›×¡,</p>
            <p>×œ×©×˜×—×•, ×•×œ×›×œ ×©××¨ ×”× ×ª×•× ×™× ×›×××•×¨ ×•×›××¤×•×¨×˜ ×œ×¢×™×œ,</p>
            <p>×‘×”×‘×™××™ ×‘×—×©×‘×•×Ÿ ×©×•×•×™× ×©×œ × ×›×¡×™× ×“×•××™× ×¨×œ×•×•× ×˜×™×™×,</p>
          <p style="margin-top: 16px;"><strong>×¡×‘×™×¨ ×œ×××•×“ ××ª ×©×•×•×™ ×”× ×›×¡ ×‘×’×‘×•×œ×•×ª, <span class="valuation-final-amount">${formatCurrency(displayFinalValue)}</span> (${finalValueText}).</strong></p>
          <p style="margin-top: 16px;">×”×›×•×œ ×‘××¦×‘×• ×”× ×•×›×—×™, ×›×¨×™×§, ×¤× ×•×™ ×•×—×•×¤×©×™ ××›×œ ××—×–×™×§, ×—×•×‘ ×•×©×™×¢×‘×•×“, × ×›×•×Ÿ ×œ×ª××¨×™×š ×—×•×•×ª ×“×¢×ª ×–×•.</p>
                </div>
        
        <!-- Declaration -->
        <div class="section-block" style="margin-top: 40px;">
          <div class="sub-title">×”×¦×”×¨×”:</div>
          <p><strong>×”× × ×™ ××¦×”×™×¨, ×›×™ ××™×Ÿ ×œ×™ ×›×œ ×¢× ×™×™×Ÿ ××™×©×™ ×‘× ×›×¡ × ×©×•× ×”×©×•××”, ×‘×‘×¢×œ×™ ×”×–×›×•×™×•×ª ×‘×• ×‘××–××™×Ÿ ×”×©×•××”.</strong></p>
          <p style="margin-top: 12px;"><strong>×”×“×•"×— ×”×•×›×Ÿ ×¢×œ ×¤×™ ×ª×§× ×•×ª ×©×××™ ×”××§×¨×§×¢×™×Ÿ (××ª×™×§×” ××§×¦×•×¢×™×ª), ×”×ª×©×›"×• â€“ 1966 ×•×¢×œ ×¤×™ ×”×ª×§× ×™× ×”××§×¦×•×¢×™×™× ×©×œ ×”×•×¢×“×” ×œ×ª×§×™× ×” ×©×××™×ª.</strong></p>
                </div>
        
        <!-- Signature -->
        <div class="signature-block section-block" style="margin-top: 60px;">
          ${
            companySettings?.signature
              ? `
            <div>
              <p>×•×œ×¨××™×” ×‘××ª×™ ×¢×œ ×”×—×ª×•×,</p>
              <img src="${companySettings.signature}" alt="×—×ª×™××” ×•×—×•×ª××ª" class="signature-image" style="margin-top: 20px;" />
              <p style="margin-top: 10px;">${normalizeText(data.shamayName, "×©× ×”×©×××™")}</p>
              <p>×›×œ×›×œ×Ÿ ×•×©×××™ ××§×¨×§×¢×™×Ÿ</p>
              <p>×¨×©×™×•×Ÿ ××¡' ${(data as any).licenseNumber || (data as any).shamaySerialNumber || data.shamaySerialNumber || "115672"}</p>
          </div>
          `
              : `
            <div>
              <p>×•×œ×¨××™×” ×‘××ª×™ ×¢×œ ×”×—×ª×•×,</p>
              <p style="margin-top: 20px;">${normalizeText(data.shamayName, "×©× ×”×©×××™")}</p>
              <p>×›×œ×›×œ×Ÿ ×•×©×××™ ××§×¨×§×¢×™×Ÿ</p>
              <p>×¨×©×™×•×Ÿ ××¡' ${(data as any).licenseNumber || (data as any).shamaySerialNumber || data.shamaySerialNumber || "115672"}</p>
            </div>
          `
          }
        </div>
      </div>
      
      ${footerBlock}
    </section>
  `;

  const css = buildBaseCss(companySettings);

  // Runtime scripts - auto pagination runs in both preview and export for consistent page breaks
  const previewScripts = isPreview
    ? [pageNumberScript, autoPaginateScript].join("\n")
    : autoPaginateScript;

  // Generate custom tables section if any custom tables exist
  const customTablesSection = generateAllCustomTablesHTML(
    (data as any).customTables,
  );

  const bodyContent = `
    <div class="document">
      ${headerBlock}
      ${introductionPage}
      ${sectionOne}
      ${sectionTwo}
      ${planningSection}
      ${considerationsSection}
      ${valuationSection}
      ${summarySection}
      ${customTablesSection}
    </div>
    ${previewScripts}
    ${(() => {
      if (!customEdits || Object.keys(customEdits).length === 0) {
        return "<script>window.__customEditsApplied = true;</script>";
      }
      const editsJson = JSON.stringify(customEdits);
      return `
    <script>
      (function() {
        const applyEdits = () => {
          try {
            const edits = ${editsJson};
            
            Object.entries(edits).forEach(([selector, html]) => {
              try {
                const elements = document.querySelectorAll(selector);
                if (!elements.length) {
                  console.warn('No elements found for selector:', selector);
                  return;
                }
                elements.forEach((element) => {
                  element.innerHTML = html;
                });
              } catch (selectorError) {
                console.error('Failed to apply edit for selector:', selector, selectorError);
              }
            });
            window.__customEditsApplied = true;
          } catch (error) {
            console.error('Error applying custom document edits:', error);
            window.__customEditsApplied = true;
          }
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', applyEdits);
        } else {
          applyEdits();
        }
      })();
    </script>
      `;
    })()}
  `;

  // PDF export CSS - clean structure for Puppeteer's header/footer system
  const pdfExportCss = !isPreview
    ? `
    /* PDF export uses Puppeteer's displayHeaderFooter system in export.js */
    /* This CSS just ensures clean HTML structure for extraction */
    
    @page { 
      size: A4; 
      margin: 0; 
    }
    
    body {
      margin: 0;
      padding: 0;
    }
    
    /* Cover page: standalone, rendered separately */
    .cover {
      position: relative;
      background: white;
    }
    
    /* Content pages: extracted and rendered with Puppeteer header/footer */
    .pages {
      position: relative;
    }
    
    /* Flatten page wrappers for natural content flow */
    .pages main .page {
      padding: 0 !important;
      margin: 0 !important;
      border: none !important;
      background: transparent !important;
    }
    
    .pages main .page-body {
      padding: 0 16px !important;
    }
    
    /* Hide inline header/footer elements (not needed with Puppeteer system) */
    .pages main .page-header-brand,
    .pages main .page-footer,
    .pages main .page-number {
      display: none !important;
    }
  `
    : "";

  // For PDF export, restructure HTML into two sections
  const customEditsScript = (() => {
    if (!customEdits || Object.keys(customEdits).length === 0) {
      return `
        <script>
          window.__customEditsApplied = true;
        </script>
      `;
    }

    const editsJson = JSON.stringify(customEdits);

    return `
      <script>
        (function() {
          const edits = ${editsJson};
          
          const applyEdits = () => {
            try {
              console.log('ğŸ”§ [Custom Edits] Starting application of', Object.keys(edits).length, 'edits');
              
              // Check if we are in export mode (nested structure)
              const docRoot = document.querySelector('.document');
              const isExportMode = !!(docRoot && docRoot.querySelector('.pages > main'));
              
              console.log('ğŸ”§ [Custom Edits] Export mode:', isExportMode);
              
              // Use document as base to support full path selectors
              const base = document;
              const pageSections = Array.from(base.querySelectorAll('section.page'));
              
              console.log('ğŸ”§ [Custom Edits] Found', pageSections.length, 'page sections');
              
              let appliedCount = 0;
              let failedCount = 0;
              
              Object.entries(edits).forEach(([selector, html]) => {
                try {
                  console.log('ğŸ”§ [Custom Edits] Processing selector:', selector.substring(0, 80) + '...');
                  let handled = false;
                  
                  if (isExportMode) {
                    // Match selectors like: div > section:nth-of-type(N) ...
                    // Find the section:nth-of-type pattern and extract page number
                    const nthOfTypeIndex = selector.indexOf('section:nth-of-type(');
                    if (nthOfTypeIndex !== -1) {
                      const start = nthOfTypeIndex + 'section:nth-of-type('.length;
                      const end = selector.indexOf(')', start);
                      if (end !== -1) {
                        const pageNumStr = selector.substring(start, end).trim();
                        const pageNum = parseInt(pageNumStr, 10);
                        if (!isNaN(pageNum)) {
                          const restOfSelector = selector.substring(end + 1);
                          console.log('ğŸ”§ [Custom Edits] âœ… Matched export selector - page number:', pageNum, 'rest:', restOfSelector.substring(0, 50));
                          
                          // In export mode: page 1 is cover (index 0), pages 2+ are content pages (index 1+)
                          // pageSections includes ALL pages in order: [cover, page1, page2, ...]
                          const pageIndex = pageNum - 1;
                          
                          if (pageIndex < 0 || pageIndex >= pageSections.length) {
                            console.warn('ğŸ”§ [Custom Edits] âŒ Page index out of range:', pageIndex, 'total pages:', pageSections.length);
                          } else {
                            const pageElement = pageSections[pageIndex];
                            const trimmedRest = restOfSelector.trim();
                            
                            if (!trimmedRest) {
                              console.log('ğŸ”§ [Custom Edits] Applying to entire page', pageNum);
                              pageElement.innerHTML = html;
                              appliedCount++;
                              handled = true;
                            } else {
                              const scopedSelector = restOfSelector.startsWith(' ')
                                ? \`:scope\${restOfSelector}\`
                                : \`:scope \${restOfSelector}\`;
                              
                              console.log('ğŸ”§ [Custom Edits] Trying scoped selector:', scopedSelector.substring(0, 80));
                              let scopedApplied = false;
                              
                              try {
                                const scopedMatches = pageElement.querySelectorAll(scopedSelector);
                                
                                if (scopedMatches.length > 0) {
                                  console.log('ğŸ”§ [Custom Edits] âœ… Found', scopedMatches.length, 'matches with scoped selector');
                                  scopedMatches.forEach((element) => {
                                    element.innerHTML = html;
                                    appliedCount++;
                                  });
                                  scopedApplied = true;
                                  handled = true;
                                } else {
                                  console.warn('ğŸ”§ [Custom Edits] âŒ No scoped matches for selector:', scopedSelector.substring(0, 80), 'on page:', pageNum);
                                }
                              } catch (scopeError) {
                                console.warn('ğŸ”§ [Custom Edits] âŒ Scoped selector failed:', scopeError.message);
                              }
                              
                              if (!scopedApplied) {
                                const fallbackSelector = trimmedRest.replace(/^>\s*/, '').trim();
                                
                                if (fallbackSelector) {
                                  console.log('ğŸ”§ [Custom Edits] Trying fallback selector:', fallbackSelector.substring(0, 80));
                                  const fallbackMatches = pageElement.querySelectorAll(fallbackSelector);
                                  
                                  if (fallbackMatches.length > 0) {
                                    console.log('ğŸ”§ [Custom Edits] âœ… Found', fallbackMatches.length, 'matches with fallback selector');
                                    fallbackMatches.forEach((element) => {
                                      element.innerHTML = html;
                                      appliedCount++;
                                    });
                                    handled = true;
                                  } else {
                                    console.warn('ğŸ”§ [Custom Edits] âŒ Fallback selector had no matches:', fallbackSelector.substring(0, 80), 'on page:', pageNum);
                                  }
                                }
                              }
                            }
                          }
                        } else {
                          console.warn('ğŸ”§ [Custom Edits] Invalid page number in selector:', pageNumStr);
                        }
                      } else {
                        console.warn('ğŸ”§ [Custom Edits] Could not find closing parenthesis for section:nth-of-type');
                      }
                    } else {
                      console.log('ğŸ”§ [Custom Edits] Selector does not contain section:nth-of-type, will try original');
                    }
                  }
                  
                  if (handled) {
                    return;
                  }
                  
                  // Fallback: try original selector
                  const elements = base.querySelectorAll(selector);
                  
                  if (!elements.length) {
                    console.warn('No elements found for selector:', selector);
                    failedCount++;
                    return;
                  }
                  
                  elements.forEach((element) => {
                    element.innerHTML = html;
                    appliedCount++;
                  });
                } catch (err) {
                  console.error('Failed to apply selector:', selector, err);
                  failedCount++;
                }
              });
              
              console.log('Custom edits applied:', appliedCount, 'succeeded,', failedCount, 'failed');
              window.__customEditsApplied = true;
            } catch (error) {
              console.error('Error applying custom edits:', error);
              window.__customEditsApplied = true;
            }
          };
          
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', applyEdits);
          } else {
            applyEdits();
          }
        })();
      </script>
    `;
  })();

  let fullHtml = "";
  if (!isPreview) {
    // PDF export: TWO separate sections - cover (standalone) and pages (with header/footer)
    // IMPORTANT: Wrap in .document to match preview structure so custom edit selectors work!
    const pdfHeaderFooter = `
      ${companySettings?.companyLogo ? `<header><img src="${companySettings.companyLogo}" alt="Company Logo" /></header>` : ""}
      ${companySettings?.footerLogo ? `<footer><img src="${companySettings.footerLogo}" alt="Footer Logo" /></footer>` : ""}
    `;

    fullHtml = `
      <!DOCTYPE html>
      <html dir="rtl" lang="he">
        <head>
          <meta charset="UTF-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1.0" />
          <style>${css}${pdfExportCss}</style>
        </head>
        <body>
          <div class="document">
            ${headerBlock}
            <div class="pages">
              ${pdfHeaderFooter}
              <main>
                ${introductionPage}
                ${sectionOne}
                ${sectionTwo}
                ${planningSection}
                ${considerationsSection}
                ${valuationSection}
                ${summarySection}
                ${customTablesSection}
                ${customEditsScript}
              </main>
            </div>
          </div>
        </body>
      </html>
    `;
  } else {
    // Preview mode: Keep existing structure
    fullHtml = `
    <!DOCTYPE html>
    <html dir="rtl" lang="he">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <style>${css}</style>
      </head>
      <body>
        ${bodyContent}
    </body>
    </html>
  `;
  }

  if (isPreview) {
    return `<style>${css}</style>${bodyContent}`;
  }

  return fullHtml;
}
